#!/usr/bin/env python
import sys
import os
import subprocess
import re
import glob
from pprint import pprint

needed_re = re.compile(r'Shared library: \[(.+)\]$')

def parse_ldconf(conf_path):
	if not os.path.exists(conf_path):
		print("warning: config file %s not found" % conf_path, file=sys.stderr)
		return
	for line in open(conf_path):
		line = line.strip()
		if not line or line.startswith("#"):
			continue
		line = line.split()
		if line[0] == "include" and line[1]:
			for incl_path in glob.glob(line[1]):
				yield from parse_ldconf(incl_path)
		else:
			yield line[0]

def get_lib_paths():
	paths = []
	if "LD_LIBRARY_PATH" in os.environ:
		paths += os.environ["LD_LIBRARY_PATH"].split(":")
	paths += parse_ldconf("/etc/ld.so.conf")
	paths += ["/lib", "/usr/lib"]
	return paths

def find_in_path(paths, basename):
	if basename.startswith("/"):
		return basename
	for _dir in paths:
		path = os.path.join(_dir, basename)
		if os.path.exists(path):
			return path

def read_needed(path):
	"""
	Read direct dependencies of an ELF file.
	"""
	deps = set()
	proc = subprocess.Popen(["readelf", "-d", path], stdout=subprocess.PIPE)
	for line in proc.stdout:
		line = line.decode("utf-8")
		m = needed_re.search(line)
		if m:
			deps.add(m.group(1))
	return deps

def show_tree(item, deps, indent=0, ctx=None):
	depth, branches = ctx or (0, [])
	if depth == 0:
		print(" "*indent + item)
	if item not in deps:
		return
	children = deps[item]
	branches += [None]
	more = len(children)
	for child in sorted(children):
		more -= 1
		branches[depth] = ("├" if more else "└") + "─"
		print(" "*indent + "".join(branches) + child)
		if child in deps:
			branches[depth] = ("│" if more else " ") + " "
			ctx = depth + 1, branches.copy()
			show_tree(child, deps, indent, ctx)

def walk_tree(head, deps):
	children = deps[head[-1]]
	for child in children:
		chain = head + [child]
		if child in deps:
			yield from walk_tree(chain, deps)
		else:
			yield chain

def flip_tree(heads, deps):
	flipped_deps = dict()
	for head in heads:
		for chain in walk_tree([head], deps):
			user = chain.pop()
			while chain:
				dep = chain.pop()
				if user not in flipped_deps:
					flipped_deps[user] = set()
				flipped_deps[user].add(dep)
				user = dep
	return flipped_deps

class LdMissing(object):
	def __init__(self, exe_path):
		self.exe_path = exe_path
		self.lib_paths = get_lib_paths()
		self.resolved_paths = dict()
		self.forward_deps = dict()
		self.reverse_deps = dict()
		self.missing_libs = set()

	def find_missing(self):
		todo = {self.exe_path}

		while todo:
			elf_name = todo.pop()

			if elf_name in self.forward_deps:
				continue

			if elf_name in self.resolved_paths:
				elf_path = self.resolved_paths[elf_name]
			else:
				elf_path = find_in_path(self.lib_paths, elf_name)
				self.resolved_paths[elf_name] = elf_path

			if elf_path is None:
				self.missing_libs.add(elf_name)
				continue

			deps = read_needed(elf_path)
			self.forward_deps[elf_name] = deps

			for dep in deps:
				if dep not in self.reverse_deps:
					self.reverse_deps[dep] = set()
				self.reverse_deps[dep].add(elf_name)

			todo |= deps

	def show_missing(self):
		for lib in self.missing_libs:
			print("Missing: %s" % lib)
			for user in self.reverse_deps[lib]:
				print("         ← %s" % user)

	def show_reverse_tree(self):
		print("Reverse dependencies:")
		for lib in self.missing_libs:
			show_tree(lib, self.reverse_deps, indent=2)

	def show_forward_tree(self):
		flipped_deps = flip_tree(self.missing_libs, self.reverse_deps)
		print("Forward dependencies:")
		show_tree(self.exe_path, flipped_deps, indent=2)

exe_path = sys.argv[1]

ldm = LdMissing(exe_path)
ldm.find_missing()
ldm.show_missing()
ldm.show_reverse_tree()
ldm.show_forward_tree()
