#!/usr/bin/env python3
import sys
import os
import subprocess
import re
import glob
from pprint import pprint

needed_re = re.compile(r'Shared library: \[(.+)\]$')

def parse_ldconf(conf_path):
	if not os.path.exists(conf_path):
		print("warning: config file %s not found" % conf_path, file=sys.stderr)
		return
	for line in open(conf_path):
		line = line.strip()
		if not line or line.startswith("#"):
			continue
		line = line.split()
		if line[0] == "include" and line[1]:
			for incl_path in glob.glob(line[1]):
				yield from parse_ldconf(incl_path)
		else:
			yield line[0]

def get_lib_paths():
	"""
	Return an array of paths where ld.so searches for libraries.
	"""
	paths = []
	if "LD_LIBRARY_PATH" in os.environ:
		paths += os.environ["LD_LIBRARY_PATH"].split(":")
	paths += parse_ldconf("/etc/ld.so.conf")
	paths += ["/lib", "/usr/lib"]
	return paths

def find_in_path(paths, basename):
	"""
	Return the first existing path of a file `basename` in given paths.
	Return None if not found.

	>>> find_in_path(os.environ["PATH"], "sh")
	"/bin/sh"
	"""
	if basename.startswith("/"):
		return basename
	for _dir in paths:
		path = os.path.join(_dir, basename)
		if os.path.exists(path):
			return path

def read_needed(path):
	"""
	Read direct dependencies of an ELF file.
	"""
	deps = set()
	proc = subprocess.Popen(["readelf", "-d", path], stdout=subprocess.PIPE)
	for line in proc.stdout:
		line = line.decode("utf-8")
		m = needed_re.search(line)
		if m:
			deps.add(m.group(1))
	return deps

def show_tree(root, deps, indent=0, ctx=None):
	"""
	Print dict `deps` {item: [children...]} starting at a given `root`
	as a textual tree. Recurse for each item in `deps[root]` as new root.

	>>> deps = {"a": {"b", "c"}, "b": {"d"}, "c": {"b", "d"}}
	>>> show_tree("a", deps)
	a
	├─b
	│ └─d
	└─c
	  ├─b
	  │ └─d
	  └─d
	"""
	depth, branches = ctx or (0, [])
	if depth == 0:
		print(" "*indent + item)
	if root not in deps:
		return
	children = deps[root]
	branches += [None]
	more = len(children)
	for child in sorted(children):
		more -= 1
		branches[depth] = ("├" if more else "└") + "─"
		print(" "*indent + "".join(branches) + child)
		if child in deps:
			branches[depth] = ("│" if more else " ") + " "
			ctx = depth + 1, branches.copy()
			show_tree(child, deps, indent, ctx)

def walk_tree(head, deps):
	"""
	Return a list containing all possible "chains" that start with `head`
	where every item is followed by an item that directly depends on it.

	>>> deps = {"a": {"b", "c"}, "b": {"c"}, "c": {"b", "d"}}
	>>> deps
	{'a': {'b', 'c'},
	 'b': {'c'},
	 'c': {'b', 'd'}}
	>>> list(walk_tree(["a"], deps))
	[['a', 'c', 'd'],
	 ['a', 'c', 'b', 'd'],
	 ['a', 'b', 'd']]
	"""
	children = deps[head[-1]]
	for child in children:
		if child in head:
			raise ValueError("dependency loop detected at %r + %r" \
				% (head, child))
		chain = head + [child]
		if child in deps and deps[child]:
			yield from walk_tree(chain, deps)
		else:
			yield chain

def flip_tree(roots, deps):
	"""
	Return a dict of reverse dependencies where each root in `roots`
	becomes a leaf if formatted as a tree. (The output is usually
	formatted as *multiple* trees, one for each key in resulting deps.)

	>>> deps
	{'a': {'b', 'c'},
	 'b': {'c'},
	 'c': {'b', 'd'}}
	>>> flip_tree(["a"], deps)
	{'d': {'c', 'b'},
	 'c': {'a'},
	 'b': {'a', 'c'}}
	>>> show_tree("d", flip_tree(["a"], deps))
	d
	├─b
	│ ├─a
	│ └─c
	│   └─a
	└─c
	  └─a
	"""
	flipped_deps = dict()
	for root in roots:
		for chain in walk_tree([root], deps):
			user = chain.pop()
			while chain:
				dep = chain.pop()
				if user not in flipped_deps:
					flipped_deps[user] = set()
				flipped_deps[user].add(dep)
				user = dep
	return flipped_deps

class LdMissing(object):
	def __init__(self, exe_path):
		self.exe_path = exe_path
		self.lib_paths = get_lib_paths()
		self.resolved_paths = dict()
		self.forward_deps = dict()
		self.reverse_deps = dict()
		self.missing_libs = set()

	def find_missing(self):
		todo = {self.exe_path}

		while todo:
			elf_name = todo.pop()

			if elf_name in self.forward_deps:
				continue

			if elf_name in self.resolved_paths:
				elf_path = self.resolved_paths[elf_name]
			else:
				elf_path = find_in_path(self.lib_paths, elf_name)
				self.resolved_paths[elf_name] = elf_path

			if elf_path is None:
				self.missing_libs.add(elf_name)
				continue

			deps = read_needed(elf_path)
			self.forward_deps[elf_name] = deps

			for dep in deps:
				if dep not in self.reverse_deps:
					self.reverse_deps[dep] = set()
				self.reverse_deps[dep].add(elf_name)

			todo |= deps

		return self.missing_libs

	def show_missing(self):
		for lib in self.missing_libs:
			print("Missing: %s" % lib)
			for user in self.reverse_deps[lib]:
				print("         ← %s" % user)

	def show_reverse_tree(self):
		print("Reverse dependencies:")
		for lib in self.missing_libs:
			show_tree(lib, self.reverse_deps, indent=2)

	def show_forward_tree(self):
		flipped_deps = flip_tree(self.missing_libs, self.reverse_deps)
		print("Forward dependencies:")
		show_tree(self.exe_path, flipped_deps, indent=2)

if __name__ == "__main__":
	exe_path = sys.argv[1]

	ldm = LdMissing(exe_path)
	missing = ldm.find_missing()
	if missing:
		ldm.show_missing()
		ldm.show_reverse_tree()
		ldm.show_forward_tree()
