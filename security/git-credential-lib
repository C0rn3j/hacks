#!/usr/bin/env python2
# -*- mode: python -*-
from __future__ import print_function
import sys

def usage():
	print("usage: %s <store> <operation>" % sys.argv[0])

def list_stores():
	print()
	print("supported stores ('*' = available):")
	for name, klass in sorted(stores.items()):
		flag = "*" if klass().available() else " "
		descr = getattr(klass, "_description_", "?")
		print("  %1s %-15s %s" % (flag, name, descr), file=sys.stderr)

def attr_is_private(k):
	return k in ("password",)

def attr_public(attr):
	return dict((k, attr[k]) for k in attr if not attr_is_private(k))

def make_uri(attr, anonymous=False):
	uri = ""
	if "protocol" in attr:
		uri += "%(protocol)s://" % attr
	if "host" in attr:
		if "username" in attr and anonymous is False:
			uri += "%(username)s@" % attr
		uri += attr["host"]
		if "port" in attr:
			uri += ":%(port)s" % attr
		uri += "/"
	if "path" in attr:
		uri += attr["path"]
	return uri

class CredStore(object):
	_description_ = None

	def __init__(self):
		raise NotImplementedError()

	def handle(self, op, *args, **kwargs):
		if not self.available():
			return {}
		try:
			func = getattr(self, "_cred_%s" % op)
		except AttributeError:
			return {}
		else:
			return func(*args, **kwargs) or {}

	def available(self):
		return False

class DummyLoopbackStore(CredStore):
	_description_ = "Dummy amnesiac store"

	def __init__(self):
		pass

	def available(self):
		return True

	def _cred_get(self, attr):
		print("get", attr, file=sys.stderr)
		return attr

	def _cred_store(self, attr):
		print("store", attr, file=sys.stderr)
		return None

	def _cred_erase(self, attr):
		print("erase", attr, file=sys.stderr)
		return None

class GnomeKeyringStore(CredStore):
	_description_ = "GNOME Keyring"

	def __init__(self):
		try:
			import glib
			import gnomekeyring

			glib.set_application_name("git")
			self.gk = gnomekeyring

		except ImportError:
			self.gk = None

	def available(self):
		return self.gk and self.gk.is_available()

	def map_attributes(self, inattr):
		outattr = {}
		for key, val in inattr.items():
			if key == "host":
				outattr["server"] = val
			elif key in ("port", "protocol"):
				outattr[key] = val
			elif key == "username":
				outattr["user"] = val
			else:
				outattr["git:%s" % key] = val
		return outattr

	def unmap_attributes(self, outattr):
		inattr = {}
		for key, val in outattr.items():
			if key.startswith("git:"):
				inattr[key[4:]] = val
			elif key in ("port", "protocol"):
				inattr[key] = val
			elif key == "server":
				inattr["host"] = val
			elif key == "user":
				inattr["username"] = val
			else:
				inattr[key] = val
		return inattr

	def _cred_get(self, attr):
		find_type = self.gk.ITEM_NETWORK_PASSWORD
		find_attr = self.map_attributes(attr_public(attr))

		try:
			results = self.gk.find_items_sync(find_type, find_attr)
		except self.gk.NoMatchError:
			return None

		for res in results:
			attr.update(res.attributes)
			attr["password"] = res.secret

		return self.unmap_attributes(attr)

	def _cred_store(self, attr):
		keyring = self.gk.get_default_keyring_sync()
		item_type = self.gk.ITEM_NETWORK_PASSWORD
		display_name = attr["host"]
		item_attr = self.map_attributes(attr_public(attr))
		secret = attr["password"]
		update = True

		self.gk.item_create_sync(keyring, item_type, display_name,
					item_attr, secret, update)

	def _cred_erase(self, attr):
		find_type = self.gk.ITEM_NETWORK_PASSWORD
		find_attr = self.map_attributes(attr_public(attr))

		try:
			results = self.gk.find_items_sync(find_type, find_attr)
		except self.gk.NoMatchError:
			return None

		for res in results:
			if "password" in attr and res.secret != attr["password"]:
				continue
			self.gk.item_delete_sync(res.keyring, res.item_id)

class Win32CredentialStore(CredStore):
	_description_ = "Windows Credential Manager"

	do_prompt = True

	ERROR_NOT_FOUND = 1168
	ERROR_CANCELLED = 1223
	SILENT_ERRORS = {ERROR_NOT_FOUND, ERROR_CANCELLED}

	def __init__(self):
		try:
			import win32con, win32cred, pywintypes
			self._con = win32con
			self._cred = win32cred
			self._types = pywintypes
		except ImportError:
			self._cred = None

	def available(self):
		return bool(self._cred and self._cred.CredUIPromptForCredentials)

	def make_target_name(self, attr):
		return make_uri(attr, anonymous=True)

	def _cred_get(self, attr):
		target = self.make_target_name(attr)
		cred = None

		try:
			cred = self._cred.CredRead(target, self._cred.CRED_TYPE_GENERIC)
		except self._types.error as e:
			if e.winerror == self.ERROR_NOT_FOUND:
				pass
			else:
				print("Error: %s(): %s" % (e.funcname, e.strerror),
					file=sys.stderr)
				return None

		if cred:
			if cred["UserName"] is not None:
				attr["username"] = cred["UserName"]
			if len(cred["CredentialBlob"]):
				attr["password"] = cred["CredentialBlob"].decode("utf-16-le")
			for cred_attr in cred["Attributes"]:
				attr[cred_attr["Keyword"]] = cred_attr["Value"]
			return attr
		elif self.do_prompt:
			user = attr.get("username", None)
			passwd = None
			persist = None

			flags = self._cred.CREDUI_FLAGS_GENERIC_CREDENTIALS
			flags |= self._cred.CREDUI_FLAGS_EXCLUDE_CERTIFICATES
			# Git will store the credentials itself after confirming them
			flags |= self._cred.CREDUI_FLAGS_DO_NOT_PERSIST

			ui_info = dict(Parent=None,
					#CaptionText="",
					MessageText="Please enter login details for %s:" % target,
					Banner=None)

			try:
				(user, passwd, persist) = self._cred.CredUIPromptForCredentials(
									TargetName=target,
									UserName=user,
									Save=False,
									Flags=flags,
									UiInfo=ui_info)
			except self._types.error as e:
				if e.winerror == self.ERROR_CANCELLED:
					return None
				else:
					print("Error: %s(): %s" % (e.funcname, e.strerror),
						file=sys.stderr)

			if len(user) and len(passwd):
				attr["username"] = user
				attr["password"] = passwd
				return attr
			else:
				return None
		else:
			return None

	def _cred_store(self, attr):
		target = self.make_target_name(attr)

		cred = {
			"Type": self._cred.CRED_TYPE_GENERIC,
			"Flags": 0,
			"TargetName": target,
			"Persist": self._cred.CRED_PERSIST_ENTERPRISE,
			"Attributes": [],
		}
		for key, val in attr.items():
			if key in {"host"}:
				continue
			elif key == "username":
				cred["UserName"] = val
			elif key == "password":
				cred["CredentialBlob"] = val
			elif not attr_is_private(key):
				cred["Attributes"].append(
							{"Keyword": key,
							"Flags": 0,
							"Value": val})

		try:
			self._cred.CredWrite(cred, 0)
		except self._types.error as e:
			if e.winerror not in self.SILENT_ERRORS:
				print("Error: %s(): %s" % (e.funcname, e.strerror),
					file=sys.stderr)

		return None

	def _cred_erase(self, attr):
		target = self.make_target_name(attr)

		try:
			self._cred.CredDelete(target, self._cred.CRED_TYPE_GENERIC)
		except self._types.error as e:
			if e.winerror not in self.SILENT_ERRORS:
				print("Error: %s(): %s" % (e.funcname, e.strerror),
					file=sys.stderr)

		return None

class Win32CredentialStore_NoUI(Win32CredentialStore):
	_description_ = "Windows Credential Manager (no UI)"
	do_prompt = False

stores = {
	"dummy": DummyLoopbackStore,
	"gnomekeyring": GnomeKeyringStore,
	"windows": Win32CredentialStore,
	"windows-nogui": Win32CredentialStore_NoUI,
}

if __name__ == "__main__":
	try:
		store_name, op = sys.argv[1:]
	except ValueError:
		usage()
		list_stores()
		sys.exit(2)

	if store_name not in stores:
		print("error: store %r not supported" % store_name, file=sys.stderr)
		list_stores()
		sys.exit(1)

	store = stores[store_name]()
	attr = {}

	if not store.available():
		print("error: store %r currently not available" % store_name, file=sys.stderr)
		sys.exit(1)

	# Let's assume UTF-8 inputs, even though gitcredentials(7) says otherwise.
	# DBus dislikes binary anyway...

	#sys.stdin = open("/dev/stdin", "rb")
	#sys.stdout = open("/dev/stdout", "wb")

	for line in sys.stdin.read().splitlines():
		try:
			_ = line.decode("utf-8")
			key, val = line.rstrip("\n").split("=", 1)
		except ValueError:
			print("error: invalid input %r" % line, file=sys.stderr)
			sys.exit(1)
		else:
			attr[key] = val

	cred = store.handle(op, attr)

	if cred:
		for key, val in cred.items():
			line = "%s=%s\n" % (key, val)
			sys.stdout.write(line)
