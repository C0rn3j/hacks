#!/usr/bin/env perl
use feature qw(state);
use open qw(:std :utf8);
use strict;
use warnings;
use Archive::Zip qw(:ERROR_CODES);
use Crypt::X509;
use File::Basename qw(basename dirname);
use File::Path qw(make_path);
use MIME::Base64;
use Nullroute::Lib;
use XML::Simple;

sub bigint_hex {
    my ($i) = @_;

    if (ref $i eq "Math::BigInt") {
        return $i->as_hex =~ s/^0x//r;
    } else {
        return sprintf("%x", $i);
    }
}

sub parse_xmldsig {
    my ($data) = @_;

    my $xs = XML::Simple->new;
    my $xml = $xs->XMLin($data,
                         NSExpand => 1,
                         ForceArray => [
                            "{http://www.w3.org/2000/09/xmldsig#}Signature",
                         ]);

    if ($::debug >= 2) {
        require Data::Dumper;
        print Data::Dumper->new([$xml])->Indent(1)->Dump;
    }

    if (my $data = $xml->{"{http://www.w3.org/2000/09/xmldsig#}Signature"}) {
        return map {decode_base64($_)}
               map {
                    $_->{"{http://www.w3.org/2000/09/xmldsig#}KeyInfo"}
                      ->{"{http://www.w3.org/2000/09/xmldsig#}X509Data"}
                      ->{"{http://www.w3.org/2000/09/xmldsig#}X509Certificate"}
               } @$data;
    }
}

sub safe_filename {
    my ($str) = @_;

    $str =~ s/[ \/\\"?*<>:]/_/g;
    return $str;
}

sub make_cert_filename {
    my ($cert_der) = @_;

    my $cert = Crypt::X509->new(cert => $cert_der);
    _info("found cert '".$cert->subject_cn."' (".$cert->issuer_cn.")");

    my $issuer = safe_filename($cert->issuer_cn);
    my $subj = safe_filename($cert->subject_cn);
    my $serial = bigint_hex($cert->serial);

    return $issuer."/".$subj."_".$serial.".crt";
}

sub increment_filename {
    my ($str) = @_;

    if ($str =~ /^(.+?) \((\d+)\)(\.[^.]+)?$/) {
        _debug("head '$1' mid '$2' tail '".($3//"")."'");
        return $1." (".($2+1).")".$3;
    }
    elsif ($str =~ /^(.+?)(\.[^.]+)?$/) {
        _debug("head '$1' tail '".($2//"")."'");
        return $1." (1)".$2;
    }
}

sub write_certificate {
    my ($cert_der) = @_;
    state %seen;

    my $out_file = make_cert_filename($cert_der);
    if ($seen{$cert_der}++) {
        _debug("certificate already seen, skipping");
        return;
    }
    overwrite_check:
    if (-e $out_file) {
        if (open(my $f, "<:raw", $out_file)) {
            my $old_data;
            $f->read($old_data, 8192);
            $f->close;
            if ($old_data eq $cert_der) {
                _debug("identical certificate already stored, skipping");
                return;
            } else {
                _debug("different certificate stored, trying next filename");
                $out_file = increment_filename($out_file);
                goto overwrite_check;
            }
        }
    }
    make_path(dirname($out_file));
    _debug("writing '$out_file'");
    if (open(my $f, ">:raw", $out_file)) {
        $f->print($cert_der);
        $f->close;
    } else {
        _err("could not open '$out_file': $!");
    }
}

utf8::decode($_) for @ARGV;

for my $adoc (@ARGV) {
    if (! -e $adoc) {
        _err("skipping '$adoc': does not exist");
    }
    elsif ($adoc =~ /\.(adoc|bdoc|asice|sce)$/i) {
        _log2("parsing '$adoc'");
        my $zip = Archive::Zip->new;
        if ($zip->read($adoc) != AZ_OK) {
            _die("could not read file '$adoc'");
        }

        my @sigs = $zip->membersMatching("^META-INF/(signatures/)?signatures.*\\.xml\$");
        for my $sig_file (@sigs) {
            _debug("- found sig file '".$sig_file->{fileName}."'");
            my $data = $zip->contents($sig_file);
            my @cert_der = parse_xmldsig($data);
            if (@cert_der) {
                write_certificate($_) for @cert_der;
            } else {
                _err("no certificates found in '$adoc' [".$sig_file->{fileName}."]");
            }
        }
    }
    elsif ($adoc =~ /\.ddoc$/i) {
        _log2("parsing '$adoc' (DigiDoc)");

        if (open(my $f, "<:raw", $adoc)) {
            my @cert_der = parse_xmldsig($f);
            if (@cert_der) {
                write_certificate($_) for @cert_der;
            } else {
                _err("no certificates found in '$adoc'");
            }
            $f->close;
        }
    }
    elsif ($adoc =~ /\.(crt|cert|cer)$/i) {
        _log2("parsing bare certificate '$adoc'");

        if (open(my $f, "<:raw", $adoc)) {
            my $data;
            $f->read($data, 8192);
            $f->close;
            if ($data =~ /^-----BEGIN/) {
                _err("importing of PEM certificates is currently not supported");
                next;
            }
            write_certificate($data);
        } else {
            _err("could not open '$adoc': $!");
        }
    }
    else {
        _err("skipping '$adoc': not an .adoc file");
    }
}

# vim: ts=4:sw=4:et
