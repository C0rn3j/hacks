#!/usr/bin/env perl
use feature qw(state);
use open qw(:std :utf8);
use strict;
use warnings;
use Archive::Zip qw(:ERROR_CODES);
use Crypt::X509;
use File::Basename qw(basename dirname);
use File::Path qw(make_path);
use File::Spec::Functions qw(catfile);
use Getopt::Long qw(:config bundling no_ignore_case);
use MIME::Base64;
use Nullroute::Lib;
use XML::Simple;

my %Opt;

sub bigint_hex {
    my ($i) = @_;

    if (ref $i eq "Math::BigInt") {
        return $i->as_hex =~ s/^0x//r;
    } else {
        return sprintf("%x", $i);
    }
}

sub parse_xmldsig {
    my ($data) = @_;

    my $xs = XML::Simple->new;
    my $xml = $xs->XMLin($data,
                         NSExpand => 1,
                         ForceContent => 1,
                         ForceArray => [
                            "{http://www.w3.org/2000/09/xmldsig#}Signature",
                         ]);

    if ($::debug >= 2) {
        require Data::Dumper;
        print Data::Dumper->new([$xml])->Indent(1)->Dump;
    }

    if (my $data = $xml->{"{http://www.w3.org/2000/09/xmldsig#}Signature"}) {
        map {decode_base64($_)}
            map {$_->{"{http://www.w3.org/2000/09/xmldsig#}KeyInfo"}
                   ->{"{http://www.w3.org/2000/09/xmldsig#}X509Data"}
                   ->{"{http://www.w3.org/2000/09/xmldsig#}X509Certificate"}
                   ->{"content"}}
                @$data;
    }
}

sub safe_filename {
    my ($str) = @_;

    $str =~ s/[ \/\\"?*<>:]/_/g;
    return $str;
}

sub make_cert_filename {
    my ($cert) = @_;

    _info("found cert '".$cert->subject_cn."' (".$cert->issuer_cn.")");

    my $issuer = safe_filename($cert->issuer_cn);
    my $subj = safe_filename($cert->subject_cn);
    my $serial = bigint_hex($cert->serial);

    return $issuer."/".$subj."_".$serial.".crt";
}

sub increment_filename {
    my ($str) = @_;

    if ($str =~ /^(.+?) \((\d+)\)(\.[^.]+)?$/) {
        _debug("head '$1' mid '$2' tail '".($3//"")."'");
        return $1." (".($2+1).")".$3;
    }
    elsif ($str =~ /^(.+?)(\.[^.]+)?$/) {
        _debug("head '$1' tail '".($2//"")."'");
        return $1." (1)".$2;
    }
}

sub write_certificate {
    my ($cert_der) = @_;
    state %seen;

    if ($seen{$cert_der}++) {
        _debug("certificate already seen, skipping");
        return;
    }

    my $cert = Crypt::X509->new(cert => $cert_der);
    if (!$cert || $cert->{_error}) {
        _err("could not parse certificate");
        return;
    }

    my $out_dir = $Opt{output_dir} // ".";
    my $out_file = catfile($out_dir, make_cert_filename($cert));
    overwrite_check:
    if (-e $out_file) {
        if (open(my $f, "<:raw", $out_file)) {
            my $old_data;
            $f->read($old_data, 8192);
            $f->close;
            if ($old_data eq $cert_der) {
                _debug("identical certificate already stored, skipping");
                return;
            } else {
                _debug("different certificate stored, trying next filename");
                $out_file = catfile($out_dir, increment_filename($out_file));
                goto overwrite_check;
            }
        }
    }
    make_path(dirname($out_file));
    _info("writing '$out_file'");
    if (open(my $f, ">:raw", $out_file)) {
        $f->print($cert_der);
        $f->close;
    } else {
        _err("could not open '$out_file': $!");
    }
}

utf8::decode($_) for @ARGV;

GetOptions(
    "format=s" => \$Opt{force_format},
    "o|output-dir=s" => \$Opt{output_dir},
);

for my $adoc (@ARGV) {
    my $format;

    if (! -e $adoc) {
        _err("skipping '$adoc': does not exist");
    }
    elsif ($Opt{force_format}) {
        $format = $Opt{force_format};
    }
    elsif ($adoc =~ /\.(adoc|bdoc|asice|sce)$/i) {
        $format = "asic-e";
    }
    elsif ($adoc =~ /\.(ddoc|xml)$/i) {
        $format = "xml-dsig";
    }
    elsif ($adoc =~ /\.(crt|cert|cer|pem)$/i) {
        $format = "x509";
    }
    else {
        _err("skipping '$adoc': unknown file format");
    }

    if (!$format) {
        next;
    }
    elsif ($format =~ /^(adoc|bdoc|asic-e)$/) {
        _log2("parsing '$adoc' (ADOC or ASiC-E)");

        my $zip = Archive::Zip->new;
        if ($zip->read($adoc) != AZ_OK) {
            _die("could not read file '$adoc'");
        }

        my @sigs = $zip->membersMatching("^META-INF/(signatures/)?signatures.*\\.xml\$");
        for my $sig_file (@sigs) {
            _debug("- found sig file '".$sig_file->{fileName}."'");
            my $data = $zip->contents($sig_file);
            my @cert_der = parse_xmldsig($data);
            if (@cert_der) {
                write_certificate($_) for @cert_der;
            } else {
                _err("no certificates found in '$adoc' [".$sig_file->{fileName}."]");
            }
        }
    }
    elsif ($format eq "digidoc" || $format eq "xml-dsig") {
        _log2("parsing '$adoc' (DigiDoc or raw XML-DSig)");

        if (open(my $f, "<:raw", $adoc)) {
            my @cert_der = parse_xmldsig($f);
            if (@cert_der) {
                write_certificate($_) for @cert_der;
            } else {
                _err("no certificates found in '$adoc'");
            }
            $f->close;
        }
    }
    elsif ($format eq "x509") {
        _log2("parsing bare certificate '$adoc'");

        my $pem_re = qr/^-----BEGIN[ ]CERTIFICATE-----\r?\n
                        ([A-Za-z0-9\/+\r\n]+ =*)\r?\n
                        -----END[ ]CERTIFICATE-----\r?$/msx;

        if (open(my $f, "<:raw", $adoc)) {
            my $data;
            $f->read($data, 8192);
            $f->close;
            if ($data =~ /^-----/m) {
                while ($data =~ /$pem_re/g) {
                    my $cert_der = decode_base64($1);
                    write_certificate($cert_der);
                }
            } else {
                write_certificate($data);
            }
        } else {
            _err("could not open '$adoc': $!");
        }
    }
    else {
        _err("unknown file format '$format'");
    }
}

# vim: ts=4:sw=4:et
