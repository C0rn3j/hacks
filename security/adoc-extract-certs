#!/usr/bin/env perl
use feature qw(state);
use open qw(:std :utf8);
use strict;
use warnings;
use Archive::Zip qw(:ERROR_CODES);
use Crypt::X509;
use File::Basename qw(basename dirname);
use File::Path qw(make_path);
use MIME::Base64;
use Nullroute::Lib;
use XML::Simple;

sub bigint_hex {
    my ($i) = @_;

    if (ref $i eq "Math::BigInt") {
        return $i->as_hex =~ s/^0x//r;
    } else {
        return sprintf("%x", $i);
    }
}

sub parse_sig_xml {
    my ($data) = @_;

    my $xs = XML::Simple->new;

    $data = $xs->XMLin($data);
    $data = $data->{Signature}->{KeyInfo}->{X509Data}->{X509Certificate};
    $data = decode_base64($data);
    return $data;
}

sub safe_filename {
    my ($str) = @_;

    $str =~ s/[ \/\\"?*<>:]/_/g;
    return $str;
}

sub make_cert_filename {
    my ($cert_der) = @_;

    my $cert = Crypt::X509->new(cert => $cert_der);
    _info("found cert '".$cert->subject_cn."' (".$cert->issuer_cn.")");

    my $issuer = safe_filename($cert->issuer_cn);
    my $subj = safe_filename($cert->subject_cn);
    my $serial = bigint_hex($cert->serial);

    return $issuer."/".$subj."_".$serial.".crt";
}

sub increment_filename {
    my ($str) = @_;

    if ($str =~ /^(.+?) \((\d+)\)(\.[^.]+)?$/) {
        _debug("head '$1' mid '$2' tail '".($3//"")."'");
        return $1." (".($2+1).")".$3;
    }
    elsif ($str =~ /^(.+?)(\.[^.]+)?$/) {
        _debug("head '$1' tail '".($2//"")."'");
        return $1." (1)".$2;
    }
}

sub write_certificate {
    my ($cert_der) = @_;
    state %seen;

    my $out_file = make_cert_filename($cert_der);
    if ($seen{$cert_der}++) {
        _debug("certificate already seen, skipping");
        return;
    }
    overwrite_check:
    if (-e $out_file) {
        if (open(my $f, "<:raw", $out_file)) {
            my $old_data;
            $f->read($old_data, 8192);
            $f->close;
            if ($old_data eq $cert_der) {
                _debug("identical certificate already stored, skipping");
                return;
            } else {
                _debug("different certificate stored, trying next filename");
                $out_file = increment_filename($out_file);
                goto overwrite_check;
            }
        }
    }
    make_path(dirname($out_file));
    _debug("writing '$out_file'");
    if (open(my $f, ">:raw", $out_file)) {
        $f->print($cert_der);
        $f->close;
    } else {
        _err("could not open '$out_file': $!");
    }
}

utf8::decode($_) for @ARGV;

for my $adoc (@ARGV) {
    if (! -e $adoc) {
        _err("skipping '$adoc': does not exist");
    }
    elsif ($adoc =~ /\.adoc$/i) {
        _log2("parsing '$adoc'");
        my $zip = Archive::Zip->new;
        if ($zip->read($adoc) != AZ_OK) {
            _die("could not read file '$adoc'");
        }

        my @sigs = $zip->membersMatching("^META-INF/signatures/signatures.*\\.xml\$");
        for my $sig_file (@sigs) {
            my $data = $zip->contents($sig_file);
            my $cert_der = parse_sig_xml($data);
            write_certificate($cert_der);
        }
    }
    elsif ($adoc =~ /\.(crt|cert|cer)$/i) {
        _log2("parsing bare certificate '$adoc'");

        if (open(my $f, "<:raw", $adoc)) {
            my $data;
            $f->read($data, 8192);
            $f->close;
            if ($data =~ /^-----BEGIN/) {
                _err("importing of PEM certificates is currently not supported");
                next;
            }
            write_certificate($data);
        } else {
            _err("could not open '$adoc': $!");
        }
    }
    else {
        _err("skipping '$adoc': not an .adoc file");
    }
}

# vim: ts=4:sw=4:et
