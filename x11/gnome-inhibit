#!/usr/bin/env perl
# gnome-inhibit - temporarily suspend "session idle" check in GNOME
#
# Â© 2012 Mantas M. <grawity@gmail.com>
# Released under WTFPL v2 <http://sam.zoy.org/wtfpl/>
use v5.10;
use warnings;
use strict;
use locale;
use Getopt::Long qw(:config no_ignore_case bundling);
use List::Util qw(max);
use Net::DBus;
use POSIX;

my %FLAGS = (
	"logout"	=> 1<<0,
	"switch-user"	=> 1<<1,
	"suspend"	=> 1<<2,
	"idle"		=> 1<<3,
	"automount"	=> 1<<4,
);

my $bus	= Net::DBus->session;

sub SessionManager {
	$bus
	->get_service("org.gnome.SessionManager")
	->get_object(shift // "/org/gnome/SessionManager")
}

sub usage {
	say for
	"Usage: gnome-inhibit [options]",
	"Usage: gnome-inhibit [options] <command> [args...]",
	"Usage: gnome-inhibit --list",
	"",
	"  -f, --flags <flags>           Inhibit flags (default: 'idle')",
	"  -l, --list                    List active inhibitors",
	"  -r, --reason <reason>         Inhibit reason",
	"",
	"Flags can be specified as a comma- or colon-separated list of names.",
	"Supported flags are: ".join(" ", sort keys %FLAGS),
	"",
	"If <command> is given, inhibit will last until the command exits; otherwise,",
	"this tool will keep running until manually killed/terminated.",
	;
	exit(0);
}

sub maxlength {
	my ($attr, @items) = @_;
	(max map {length $_->{$attr}} @items) // 0;
}

sub flags_to_string {
	my ($bits) = @_;
	$bits ? join(",", sort grep {$bits & $FLAGS{$_}} keys %FLAGS) : "none";
}

sub string_to_flags {
	my $flagstr = shift;
	my $flags = 0;
	for (split(/[:,|]/, $flagstr)) {
		if ($_ eq 'all') {
			$flags |= 0x7fffffff;
		} elsif (defined $FLAGS{$_}) {
			$flags |= $FLAGS{$_};
		} elsif (/^([0-9]+|0x[0-9a-f]+)$/) {
			$flags |= int $_;
		} else {
			warn "Unknown inhibit flag: '$_'\n";
		}
	}
	return $flags;
}

sub get_inhibitors {
	sort {$a->{app_id} cmp $b->{app_id}}
	map {
		my $ih = SessionManager($_);
		my $flags = $ih->GetFlags;
		{
			path      => $_,
			app_id    => $ih->GetAppId,
			client_id => eval {$ih->GetClientId} // "(none)",
			flags     => $flags,
			szflags   => flags_to_string($flags),
			reason    => eval {$ih->GetReason} // "(none)",
			xid       => $ih->GetToplevelXid,
		};
	} @{SessionManager->GetInhibitors};
}

sub display_inhibitors {
	my (@inhibitors) = @_;

	my $len_app_id = max(11, maxlength app_id => @inhibitors);
	my $len_reason = max(6,  maxlength reason => @inhibitors);
	my $len_flags  = max(8,  maxlength szflags => @inhibitors);

	printf "%-*s  %-*s  %-*s\n",
		$len_app_id,	"APPLICATION",
		$len_reason,	"REASON",
		$len_flags,	"INHIBITS";

	for my $v (@inhibitors) {
		printf "%-*s  %-*s  %-*s\n",
			$len_app_id,	$v->{app_id},
			$len_reason,	$v->{reason},
			$len_flags,	$v->{szflags};
	}
}

my $do_list	= 0;

my $app_id	= "gnome-inhibit";
my $top_xid	= 0;
my $reason	= "User-initiated inhibit";
my $flagstr	= "idle";

GetOptions(
	'l|list'	=> \$do_list,
	'f|flags=s'	=> \$flagstr,
	'r|reason=s'	=> \$reason,
	'x|xid=i'	=> \$top_xid,
	'help'		=> \&usage,
) or exit(2);

if ($do_list) {
	display_inhibitors(get_inhibitors);
	exit(0);
} else {
	my $flags = string_to_flags($flagstr);
	if (!$flags) {
		warn "Error: No inhibit flags given.\n";
		exit 2;
	}

	my $cookie = SessionManager->Inhibit($app_id, $top_xid, $reason, $flags);
	if (!$cookie) {
		print "$app_id: inhibit failed\n";
		exit 1;
	}

	my @cmd = @ARGV;
	my $return = 0;

	if (@cmd) {
		print "$app_id: executing: @cmd\n";
		$return = system {$cmd[0]} @cmd;
		$return = POSIX::WEXITSTATUS($return);
	} else {
		$SIG{INT} = sub {
			print "$app_id: SIGINT caught, exiting\n";
			SessionManager->Uninhibit($cookie);
			exit(0);
		};
		print "$app_id: pausing until signal; use Ctrl-C to interrupt\n";
		POSIX::pause();
	}

	SessionManager->Uninhibit($cookie);
	exit($return);
}
