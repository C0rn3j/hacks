#!/usr/bin/env perl
# gnome-inhibit - temporarily suspend "session idle" check in GNOME
#
# Â© 2012 Mantas M. <grawity@gmail.com>
# Released under WTFPL v2 <http://sam.zoy.org/wtfpl/>
use v5.10;
use warnings;
use strict;
use locale;
use Getopt::Long qw(:config no_ignore_case bundling require_order);
use List::Util qw(max);
use Net::DBus;
use POSIX;

# Flags tracked by GNOME session manager (gnome-session/gsm-inhibitor.h)
my %FLAGS = (
	"logout"	=> 1<<0,
	"switch-user"	=> 1<<1,
	"suspend"	=> 1<<2,
	"idle"		=> 1<<3,
	"automount"	=> 1<<4,
);

my $bus	= Net::DBus->session;

sub SessionManager {
	$bus
	->get_service("org.gnome.SessionManager")
	->get_object(shift // "/org/gnome/SessionManager")
}

sub usage {
	say for
	"Usage: gnome-inhibit [options] [<command> [args...]]",
	"Usage: gnome-inhibit [options] {--list|--test}",
	"",
	"  -a, --app-id <application>    Application name to identify ourselves as",
	"  -f, --flags <flags>           Inhibitor flags (default: 'idle')",
	"      --help                    This message",
	"  -l, --list                    List active inhibitors",
	"  -r, --reason <reason>         Inhibit reason",
	"  -t, --test                    Test if any inhibitors are present",
	"  -v, --verbose                 Verbose mode",
	"",
	"Flags can be specified as a comma- or colon-separated list, or the word \'all\'.",
	"Supported flags are: ".join(" ", sort keys %FLAGS),
	"",
	"If <command> is given, inhibit will last until the command exits; otherwise,",
	"this tool will keep running until manually killed/terminated.",
	"",
	"If --test is given, the tool will exit with code 1 if any of the given",
	"operations from --flags are inhibited.",
	;
	exit 0;
}

sub maxlength {
	my ($attr, @items) = @_;
	(max map {length $_->{$attr}} @items) // 0;
}

sub printrow {
	my (@items) = @_;
	my $columns = @items;
	if ($columns % 2) {
		warn "Odd number of items";
		pop @items;
		--$columns;
	}
	my $fmt = "%-*s  " x ($columns/2);
	$fmt =~ s/\s+$/\n/;
	printf $fmt, @items;
}

sub flags_to_string {
	my ($bits) = @_;
	$bits ? join(",", sort grep {$bits & $FLAGS{$_}} keys %FLAGS) : "none";
}

sub string_to_flags {
	my $flagstr = shift;
	my $flags = 0;
	for (split /[:,|]/, $flagstr) {
		if ($_ eq 'all') {
			$flags |= 0xffffffff;
		} elsif (defined $FLAGS{$_}) {
			$flags |= $FLAGS{$_};
		} elsif (/^([0-9]+|0x[0-9a-f]+)$/) {
			$flags |= int $_;
		} else {
			warn "Unknown inhibit flag: '$_'\n";
		}
	}
	return $flags;
}

sub get_inhibitors {
	sort {$a->{app_id} cmp $b->{app_id}}
	map {
		my $ih = SessionManager($_);
		my $flags = $ih->GetFlags;
		{
			path      => $_,
			app_id    => $ih->GetAppId,
			client_id => eval {$ih->GetClientId} // "(none)",
			reason    => eval {$ih->GetReason} // "(none)",
			flags     => $flags,
			szflags   => flags_to_string($flags),
			top_xid   => $ih->GetToplevelXid,
		};
	} @{SessionManager->GetInhibitors};
}

sub display_inhibitors {
	my ($verbose, @inhibitors) = @_;

	my %header = (
		app_id    => "APPLICATION",
		client_id => "CLIENT",
		reason    => "REASON",
		flags     => "FLAG",
		szflags   => "INHIBITS",
		top_xid   => "WINDOW",
	);

	my @fields = $verbose
		? qw(app_id reason flags szflags client_id top_xid)
		: qw(app_id reason szflags);

	my %len = map {$_ => max(length($header{$_}),
				maxlength($_, @inhibitors))} @fields;

	printrow map {$len{$_}, $header{$_}} @fields;

	for my $v (@inhibitors) {
		printrow map {$len{$_}, $v->{$_}} @fields;
	}
}

my $do_list	= 0;
my $do_test	= 0;
my $verbose	= 0;
my $app_id	= "gnome-inhibit";
my $reason	= "User-initiated inhibit";
my $flagstr	= "idle";
my $top_xid	= 0;

GetOptions(
	'a|app-id=s'	=> \$app_id,
	'f|flags=s'	=> \$flagstr,
	'l|list'	=> \$do_list,
	'r|reason=s'	=> \$reason,
	't|test'	=> \$do_test,
	'v|verbose'	=> \$verbose,
	'x|xid=o'	=> \$top_xid,
	'help'		=> \&usage,
) or exit(2);

if ($do_list) {
	display_inhibitors($verbose, get_inhibitors);
	exit 0;
} elsif ($do_test) {
	my $flags = string_to_flags($flagstr);
	if (!$flags) {
		warn "Error: No inhibit flags given.\n";
		exit 2;
	}

	if (SessionManager->IsInhibited($flags)) {
		say "yes" if $verbose;
		exit 1;
	} else {
		say "no" if $verbose;
		exit 0;
	}
} else {
	my $flags = string_to_flags($flagstr);
	if (!$flags) {
		warn "Error: No inhibit flags given.\n";
		exit 2;
	}

	my $cookie = SessionManager->Inhibit($app_id, $top_xid, $reason, $flags);
	if ($cookie) {
		print "$app_id: inhibited: ".flags_to_string($flags)."\n" if $verbose;
	} else {
		warn "$app_id: inhibit failed\n";
		exit 1;
	}

	my @cmd = @ARGV;
	my $return = 0;

	if (@cmd) {
		print "$app_id: executing: @cmd\n" if $verbose;
		$return = system {$cmd[0]} @cmd;
		$return = POSIX::WEXITSTATUS($return);
	} else {
		$SIG{INT} = sub {
			print "$app_id: SIGINT caught, exiting\n" if $verbose;
			SessionManager->Uninhibit($cookie);
			exit 0;
		};
		print "$app_id: pausing until signal; use Ctrl-C to interrupt\n";
		POSIX::pause();
	}

	SessionManager->Uninhibit($cookie);
	exit $return;
}
