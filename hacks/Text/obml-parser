#!/usr/bin/env python
# A barebones parser for OBML files used by Opera Mini
#
# Originally intended to extract original URLs from saved pages, after Opera dropped
# binary compatibilty between minor releases and left me with a bunch of unreadable
# saved pages in v15 â€” and it does that.

import os
import sys
import struct

class Parser():
    def __init__(self, path):
        self.path = path
        self.fh = open(path, 'rb')
        self.url_base = "\0"

    def debug(self, typ, data):
        if os.environ.get("DEBUG"):
            print("\033[33m", "#", typ, repr(data), "\033[m", file=sys.stderr)
        return data

    def read(self, length):
        buf = self.fh.read(length)
        if len(buf) < length:
            raise IOError("Hit EOF after %d/%d bytes" % (len(buf), length))
        return self.debug("raw[%d]" % length, buf)

    def read_byte(self):
        length = 1
        buf = self.fh.read(length)
        if len(buf) < length:
            raise IOError("Hit EOF after %d/%d bytes" % (len(buf), length))

        data, = struct.unpack('>B', buf)
        return self.debug("byte", data)

    def read_short(self):
        length = 2
        buf = self.fh.read(length)
        if len(buf) < length:
            raise IOError("Hit EOF after %d/%d bytes" % (len(buf), length))

        data, = struct.unpack('>H', buf)
        return self.debug("short", data)

    def read_chunk(self):
        length = self.read_short()
        buf = self.fh.read(length)
        if len(buf) < length:
            raise IOError("Hit EOF after %d/%d bytes" % (len(buf), length))

        return self.debug("chunk[%d]" % length, buf)

    def read_string(self):
        buf = self.read_chunk()
        buf = buf.decode('utf-8')
        return self.debug("-> str[%d]" % len(buf), buf)

    def read_url(self, base=None):
        buf = self.read_string()
        if buf and buf[0] == "\0":
            if not base:
                base = self.url_base
            buf = base + buf[1:]
        return self.debug("-> url[%d]" % len(buf), buf)

def infinity(start=0):
    i = start
    while True:
        yield i
        i += 1

def parse_file(arg):
    print("file =", arg)

    f = Parser(arg)

    magic = f.read(4)
    if magic == b'\x02\xd3\x55\x10':
        f.read(3)

        version = f.read_byte()
        print("version =", version)

        f.read_short() # always 240

        if version == 15:
            f.read(8)
        elif version == 16:
            f.read(5)
        else:
            raise IOError('Unknown version %d' % version)

        page_title = f.read_string()
        print("title =", page_title)
        f.read_chunk() # nil on v16, 'C\x10\x10...' on v15
        page_referer = f.read_string()
        print("referer =", page_referer)
        f.url_base = page_referer
        page_url = f.read_url()
        print("url =", page_url)

        print()

        f.read(6)

        _unk1 = None
        if arg == "99328453.obml16":
            _unk1 = 174-6
        elif arg == "56127603.obml16":
            _unk1 = 175-6
        elif arg == "90483687.obml16":
            _unk1 = 3301-6
        elif arg == "36318143.obml16":
            _unk1 = 115 - 42
        else:
            f.read(1024)

        if _unk1:
            print("---unknown---")
            f.read(_unk1)

            print("=== links ===")
            for i in infinity(start=1):
                print("-- item %d --" % i)
                type = f.read(1)
                if type == b"\x00":
                    f.read(10)
                elif type in {b"L", b"P"}:
                    # count of ???
                    n = f.read_byte()
                    for j in range(n):
                        f.read(10)
                    if n == 0:
                        # unknown trailer
                        # \x00\xe7\x00\x00\xe7\x00\x05@
                        f.read(8)
                        print("end of link section")
                        break
                    else:
                        url = f.read_url()
                        print("link =", url)
                        # unknown trailer (\x01t\x00\x00)
                        f.read(4)
                elif type in {b"I", b"N", b"S"}:
                    n = f.read_byte()
                    if n != 1:
                        print("!!! type %r n %r" % (type, n))
                        return
                    for j in range(n):
                        f.read(10)
                    # variable-length data
                    f.read_chunk()
                    # trailer (\x01t\x00\x00)
                    f.read(4)
                else:
                    f.read(64)
                    print("!!! unknown link-item type %r" % type)
                    print("! giving up"); return

            print("=== content ===")
            for i in infinity(start=1):
                print()
                print("-- content %d --" % i)
                type = f.read(1)
                if type == b"T":
                    # text block
                    f.read(1) # either \x00 or \xff
                    buf = f.read(16)
                    if buf[-1] == 0:
                        # plain text
                        buf = f.read_string()
                        #print(buf)
                    elif buf[-1] == 1:
                        # link?
                        f.read(5)
                        buf = f.read_string()
                    else:
                        print("!!! unknown T-chunk (last byte %r)" % buf[-1])
                        f.read(128)
                        print("! giving up"); return
                elif type == b"B":
                    f.read(1)
                    f.read(13)
                elif type == b"I":
                    f.read(1)
                    f.read(24)
                elif type == b"F":
                    f.read(1)
                    f.read(15)
                    f.read_chunk()
                    f.read(8)
                elif type == b"S":
                    f.read(1)
                    f.read(2)
                    for j in range(32): # I think this goes until EOF?
                        print(">> S-chunk", j+2)
                        f.read_chunk()
                    print("! giving up"); return
                else:
                    print("!!! unknown content-item type %r" % type)
                    f.read(128)
                    print("! giving up"); return

                if i > 1000:
                    print("! limit reached"); return

    elif magic == b'\x02\xce\x9a\x0c':
        f.read(10)
        page_title = f.read_string()
        f.read_chunk() # nil
        page_url = f.read_string()

        print("title =", page_title)
        print("url =", page_url)
        print()
    else:
        print("error = unrecognized OBML format")

for arg in sys.argv[1:]:
    parse_file(arg)
