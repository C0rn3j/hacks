#!/usr/bin/env python
# A barebones parser for OBML files used by Opera Mini
#
# Originally intended to extract original URLs from saved pages, after Opera dropped
# binary compatibilty between minor releases and left me with a bunch of unreadable
# saved pages in v15 â€” and it does that.

import base64
import os
import struct
import sys

from pprint import pprint

class Parser():
    def __init__(self, path):
        self.path = path
        self.fh = open(path, 'rb')
        self.url_base = "\0"

    def debug(self, typ, data):
        if os.environ.get("DEBUG"):
            c_on = "\033[33m" if sys.stdout.isatty() else ""
            c_off = "\033[m" if sys.stdout.isatty() else ""
            print(c_on, "#", typ, repr(data), c_off)
        return data

    def read(self, length):
        buf = self.fh.read(length)
        if len(buf) < length:
            raise IOError("Hit EOF after %d/%d bytes" % (len(buf), length))
        return self.debug("raw[%d]" % length, buf)

    def read_byte(self):
        length = 1
        buf = self.fh.read(length)
        if len(buf) < length:
            raise IOError("Hit EOF after %d/%d bytes" % (len(buf), length))

        data, = struct.unpack('>B', buf)
        return self.debug("byte", data)

    def read_short(self):
        length = 2
        buf = self.fh.read(length)
        if len(buf) < length:
            raise IOError("Hit EOF after %d/%d bytes" % (len(buf), length))

        data, = struct.unpack('>H', buf)
        return self.debug("short", data)

    def read_chunk(self):
        length = self.read_short()
        buf = self.fh.read(length)
        if len(buf) < length:
            raise IOError("Hit EOF after %d/%d bytes" % (len(buf), length))

        return self.debug("chunk[%d]" % length, buf)

    def read_string(self):
        buf = self.read_chunk()
        buf = buf.decode('utf-8')
        return self.debug("-> str[%d]" % len(buf), buf)

    def read_url(self, base=None):
        buf = self.read_string()
        if buf and buf[0] == "\0":
            if not base:
                base = self.url_base
            buf = base + buf[1:]
        return self.debug("-> url[%d]" % len(buf), buf)

def infinity(start=0):
    i = start
    while True:
        yield i
        i += 1

def strhex(buf):
    return " ".join(["%02X" % x for x in buf])

def parse_file(arg):
    print("file =", arg)

    f = Parser(arg)

    expected_size = f.read_byte() << 16
    expected_size |= f.read_short()
    version = f.read_byte()
    print("version =", version)

    if version == 16:
        assert(expected_size == 0x02d355)
        expected_size = f.read_byte() << 16
        expected_size |= f.read_short()

        exp_total_bytes = expected_size + 7
        exp_links_bytes = 0

        f.read(8)

        page_title = f.read_string()
        f.read_chunk() # nil on v16, 'C\x10\x10...' on v15
        page_urlbase = f.read_string()
        f.url_base = page_urlbase
        page_url = f.read_url()
        print("title =", page_title)
        print("url =", page_url)

        f.read(6)

        for i in infinity(start=1):
            type = f.read(1)
            if type == b"M":
                f.read(2)
                f.read_chunk()
            elif type == b"S":
                f.read(1)
                exp_links_bytes = f.read_short()
                break
            else:
                raise ValueError("in unknown section, unknown type %r" % type)

        print("section 1 ends at %d" % f.fh.tell())

        links_start = f.fh.tell()
        links_end = f.fh.tell() + exp_links_bytes

        while f.fh.tell() < links_end:
            print("--- links [%d] ---" % f.fh.tell())
            type = f.read(1)
            if None:
                pass
            elif type == b"\x00":
                f.read(10)
            elif type == b"i":
                # "i" image
                n = f.read_byte()
                for j in range(n):
                    f.read(10)
                img_url = f.read_url()
                f.read(2)
                img_type = f.read_string()
                print("image =", img_url)
            elif type in {b"L", b"P"}:
                # "L" link
                # "P" ??? (usually mailto link)
                n = f.read_byte()
                for j in range(n):
                    f.read(10)
                link_url = f.read_url()
                f.read(2)
                link_type = f.read_string()
                if not link_url.startswith("b:"):
                    print("link =", link_url)
            elif type in {b"I", b"N", b"S", b"w", b"W"}:
                n = f.read_byte()
                if n != 1:
                    raise ValueError("in type %r, unexpected count %d" % (type, n))
                for j in range(n):
                    f.read(10)
                f.read_chunk()
                f.read(2)
                f.read_chunk()
            else:
                raise ValueError("in link section, unknown type %r" % type)

        print("section 2 ends at %d" % f.fh.tell())
        if f.fh.tell() != links_end:
            raise ValueError("link section ended at %d, expected %d" % (f.fh.tell(), links_end))

        content_start = f.fh.tell()
        content_end = exp_total_bytes

        while f.fh.tell() < content_end:
            print("--- content [%d] ---" % f.fh.tell())
            type = f.read(1)
            if None:
                pass
            elif type == b"o":
                # TODO: not sure if actual type or just part of preceding "I"-block
                f.read_chunk()
            elif type == b"B":
                f.read(14)
            elif type == b"F":
                f.read(16)
                f.read_chunk()
                f.read_chunk()
                f.read(5)
            elif type == b"I":
                f.read(25)
            elif type == b"L":
                f.read(9)
            elif type == b"M":
                f.read(2)
                f.read_chunk()
            elif type == b"S":
                exp_files_bytes = f.read_byte() << 16
                exp_files_bytes |= f.read_short()
                files_start = f.fh.tell()
                files_end = f.fh.tell() + exp_files_bytes
                while f.fh.tell() < files_end:
                    buf = f.read_chunk()
                    yield {"_type": "file",
                           "data": buf[:16]+b"..."}
                print("files started at %d, ends at %d" % (files_start, f.fh.tell()))
                if f.fh.tell() != files_end:
                    raise ValueError("content.files section ended at %d, expected %d" % (f.fh.tell(), files_end))
            elif type == b"T":
                # text block
                f.read(16)
                color_r = 0
                color_g = 0
                color_b = 0
                #color_r = f.read_byte()
                #color_g = f.read_byte()
                #color_b = f.read_byte()
                n = f.read_byte()
                for j in range(n):
                    f.read(5)
                text = f.read_string()
                yield {"_type": "text",
                       "text": text,
                       "color": (color_r, color_g, color_b)}
            else:
                raise ValueError("in content section, unknown type %r" % type)

            if i > 1000:
                print("! limit reached"); return

        print("section 3 started at %d, ends at %d" % (content_start, f.fh.tell()))
        if f.fh.tell() != content_end:
            raise ValueError("content section ended at %d, expected %d" % (f.fh.tell(), content_end))

    elif version == 12 or version == 13:
        exp_total_bytes = expected_size + 3
        exp_links_bytes = 0

        f.read(10)

        page_title = f.read_string()
        f.read_chunk() # nil
        f.url_base = f.read_string()
        page_url = f.read_url()

        print("title =", page_title)
        print("url =", page_url)
        print()

        f.read(5)

        for i in infinity(start=1):
            print("--- section 1 item %d ---" % i)
            type = f.read(1)
            if None:
                pass
            elif type == b"M":
                if version in {12, 13}:
                    f.read(2)
                    f.read_chunk()
            elif type == b"S":
                if version in {12, 13}:
                    f.read(1)
                    exp_links_bytes = f.read_short()
                    break
            else:
                raise ValueError("in header section, unknown type %r" % type)

        print("section 1 ends at %d" % f.fh.tell())

        links_start = f.fh.tell()
        links_end = f.fh.tell() + exp_links_bytes

        while f.fh.tell() < links_end:
            print("--- links [%d] ---" % f.fh.tell())
            type = f.read(1)
            if version == 12:
                if None:
                    pass
                elif type == b"\x00":
                    f.read(1)
                    nk = f.read_byte()
                    for k in range(nk):
                        f.read_string()
                        f.read_string()
                elif type == b"i":
                    n = f.read_byte()
                    for j in range(n):
                        f.read(10)
                    img_type = f.read_string()
                    img_url = f.read_url()
                    print("image =", img_url)
                elif type == b"C":
                    f.read(24)
                elif type == b"L":
                    n = f.read_byte()
                    f.read(2)
                    for j in range(n):
                        f.read(10)
                    link_url = f.read_url()
                    print("link =", link_url)
                elif type in {b"I", b"S", b"W"}:
                    n = f.read_byte()
                    for j in range(n):
                        f.read(10)
                    f.read_chunk()
                    f.read_chunk()
                else:
                    raise ValueError("in link section, unknown type %r" % type)
            elif version == 13:
                if None:
                    pass
                elif type == b"i":
                    n = f.read_byte()
                    boxes = []
                    for j in range(n):
                        pos_x = f.read_short()
                        pos_y = f.read_byte() << 16
                        pos_y |= f.read_short()
                        size_w = f.read_short()
                        size_h = f.read_byte() << 16
                        size_h |= f.read_short()
                        boxes.append((pos_x, pos_y, size_w, size_h))
                    img_url = f.read_url()
                    f.read(2)
                    img_type = f.read_string()
                    print("image =", img_url)
                    for pos_x, pos_y, size_w, size_h in boxes:
                        yield {"_type": "image",
                               "src": img_url,
                               "type": img_type,
                               "pos": (pos_x, pos_y),
                               "size": (size_w, size_h)}
                elif type == b"L":
                    n = f.read_byte()
                    for j in range(n):
                        f.read(10)
                    link_url = f.read_url()
                    f.read(2)
                    link_type = f.read_string()
                    print("link =", link_url)
                else:
                    raise ValueError("in link section, unknown type %r" % type)

        print("section 2 ends at %d" % f.fh.tell())
        if f.fh.tell() != links_end:
            raise ValueError("link section ended at %d, expected %d" % (f.fh.tell(), links_end))

        content_start = f.fh.tell()
        content_end = exp_total_bytes

        while f.fh.tell() < content_end:
            print("--- content [%d] ---" % f.fh.tell())
            type = f.read(1)
            if None:
                pass
            elif type == b"B":
                f.read(14)
            elif type == b"F":
                f.read(16)
                f.read_chunk()
                f.read_chunk()
                f.read(3)
            elif type == b"I":
                f.read(20)
            elif type == b"L":
                f.read(9)
            elif type == b"S":
                exp_files_bytes = f.read_byte() << 16
                exp_files_bytes |= f.read_short()
                files_start = f.fh.tell()
                files_end = f.fh.tell() + exp_files_bytes
                while f.fh.tell() < files_end:
                    buf = f.read_chunk()
                    yield {"_type": "file",
                           "data": buf[:16]+b"..."}
                print("files started at %d, ends at %d" % (files_start, f.fh.tell()))
                if f.fh.tell() != files_end:
                    raise ValueError("content.files section ended at %d, expected %d" % (f.fh.tell(), files_end))
            elif type == b"T":
                pos_x = f.read_short()
                pos_y = f.read_byte() << 16
                pos_y |= f.read_short()
                f.read(6)
                color_r = f.read_byte()
                color_g = f.read_byte()
                color_b = f.read_byte()
                f.read(1)
                text = f.read_string()
                yield {"_type": "text",
                       "text": text,
                       "color": (color_r, color_g, color_b),
                       "pos": (pos_x, pos_y)}
            else:
                raise ValueError("in content section, unknown type %r" % type)

        print("section 3 started at %d, ends at %d" % (content_start, f.fh.tell()))
        if f.fh.tell() != content_end:
            raise ValueError("content section ended at %d, expected %d" % (f.fh.tell(), content_end))

    else:
        raise ValueError('unknown version %d' % version)

for arg in sys.argv[1:]:
    with open("%s.html" % arg, "w") as fout:
        for item in parse_file(arg):
            type = item["_type"]
            pprint(item)
            if type == "text":
                item_x, item_y = item["pos"]
                style = [
                    "white-space: pre",
                    "font-family: sans-serif",
                    "font-size: 10pt",
                    "color: %02x%02x%02x" % item["color"],
                    "position: absolute",
                    "left: %dpx" % item_x,
                    "top: %dpx" % item_y,
                ]
                style = "; ".join(style)
                fout.write('<div style="%s">' % style)
                fout.write(item["text"])
                fout.write('</div>')
            elif type == "image":
                item_x, item_y = item["pos"]
                item_w, item_h = item["size"]
                style = [
                    "position: absolute",
                    "left: %dpx" % item_x,
                    "top: %dpx" % item_y,
                    "width: %dpx" % item_w,
                    "height: %dpx" % item_h,
                ]
                style = "; ".join(style)
                fout.write('<img src="%s" style="%s">' % (item["src"], style))
