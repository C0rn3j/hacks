#!/usr/bin/env python
# A barebones parser for OBML files used by Opera Mini
#
# (c) 2014–2016 Mantas Mikulėnas <grawity@gmail.com>
# Released under the MIT Expat License
#
# Originally intended to extract original URLs from saved pages, after Opera dropped
# binary compatibilty between minor releases and left me with a bunch of unreadable
# saved pages in v15 — and it does that.
#
# An attempt to document the file format is at:
#   https://gist.github.com/grawity/702b31cddcc5a6622724

import base64
import os
import struct
import sys

from pprint import pprint

class Parser():
    def __init__(self, path):
        self.path = path
        self.fh = open(path, 'rb')
        self.url_base = "\0"
        self.last_x = 0
        self.last_y = 0

    def debug(self, typ, data):
        if os.environ.get("DEBUG"):
            c_on = "\033[33m" if sys.stdout.isatty() else ""
            c_off = "\033[m" if sys.stdout.isatty() else ""
            print(c_on, "#", typ, repr(data), c_off)
        return data

    # primitives

    def read(self, length):
        buf = self.fh.read(length)
        if len(buf) < length:
            raise IOError("Hit EOF after %d/%d bytes" % (len(buf), length))
        return self.debug("raw[%d]" % length, buf)

    def read_byte(self):
        length = 1
        buf = self.fh.read(length)
        if len(buf) < length:
            raise IOError("Hit EOF after %d/%d bytes" % (len(buf), length))

        data, = struct.unpack('>B', buf)
        return self.debug("byte", data)

    def read_short(self):
        length = 2
        buf = self.fh.read(length)
        if len(buf) < length:
            raise IOError("Hit EOF after %d/%d bytes" % (len(buf), length))

        data, = struct.unpack('>H', buf)
        return self.debug("short", data)

    def read_medium(self):
        length = 3
        buf = self.fh.read(length)
        if len(buf) < length:
            raise IOError("Hit EOF after %d/%d bytes" % (len(buf), length))

        data_hi, data_lo = struct.unpack('>BH', buf)
        return self.debug("medium", (data_hi << 16) | data_lo)

    def read_blob(self):
        length = self.read_short()
        buf = self.fh.read(length)
        if len(buf) < length:
            raise IOError("Hit EOF after %d/%d bytes" % (len(buf), length))

        return self.debug("chunk[%d]" % length, buf)

    # other data types

    def read_string(self):
        buf = self.read_blob()
        buf = buf.decode('utf-8')
        return self.debug("-> str[%d]" % len(buf), buf)

    def read_url(self, base=None):
        buf = self.read_string()
        if buf and buf[0] == "\0":
            if not base:
                base = self.url_base
            buf = base + buf[1:]
        return self.debug("-> url[%d]" % len(buf), buf)

    def read_color(self):
        a = self.read_byte()
        r = self.read_byte()
        g = self.read_byte()
        b = self.read_byte()
        return self.debug("-> color[argb]", (a, r, g, b))

    def read_coords(self, rel_to_abs=False):
        x = self.read_short()
        y = self.read_medium()
        if rel_to_abs:
            self.last_x = x = (self.last_x + x) & 0xFFFF
            self.last_y = y = (self.last_y + y) & 0xFFFFFF
        else:
            # in v15+, all positions are relative and never depend on
            # earlier absolute coordinates (which are only used for sizes)
            pass
        return self.debug("-> coords[%s]" % ("rel" if rel_to_abs else "abs"), (x, y))

def infinity(start=0):
    i = start
    while True:
        yield i
        i += 1

def strhex(buf):
    return " ".join(["%02X" % x for x in buf])

def rgba(argb_tuple):
    a, r, g, b = argb_tuple
    a = (a / 255) if a > 0 else 1.0
    return "rgba(%d, %d, %d, %.6f)" % (r, g, b, a)

def img_data(buf):
    if buf.startswith(b"\x89PNG\r\n"):
        img_type = "image/png"
    elif buf.startswith(b"\xff\xd8"):
        img_type = "image/jpeg"
    else:
        img_type = "application/octet-stream"
    encoded = base64.b64encode(buf).decode("us-ascii")
    return "data:%s,%s" % (img_type, encoded)

def parse_file(arg):
    print("file =", arg)

    f = Parser(arg)

    expected_size = f.read_medium()
    version = f.read_byte()
    print("version =", version)

    if version == 16:
        assert(expected_size == 0x02d355)
        expected_size = f.read_medium()
        version = f.read_byte()
        exp_total_bytes = expected_size + 7
    else:
        exp_total_bytes = expected_size + 3

    exp_links_bytes = 0

    if version == 16:
        page_size = f.read_coords()
        assert(f.read_short() == 0xFFFF)
    elif version == 15:
        f.read(10)
    elif version in {12, 13}:
        f.read(10)
    else:
        raise ValueError("bad version")

    page_title = f.read_string()
    f.read_blob() # 'C\x10\x10...' on v15, nil elsewhere
    f.url_base = f.read_string()
    page_url = f.read_url()
    yield {"_type": "head",
           "title": page_title,
           "url": page_url}

    if version >= 15:
        f.read(6)
    else:
        f.read(5)

    # metadata section

    while True:
        print("--- metadata [%d] ---" % f.fh.tell())
        type = f.read(1)
        if None:
            pass
        elif type == b"C":
            if version >= 15:
                f.read(23)
            else:
                raise ValueError("unhandled metadata chunk %r/v%r" % (type, version))
        elif type == b"M":
            f.read(2)
            f.read_blob()
        elif type == b"S":
            exp_links_bytes = f.read_medium()
            break
        else:
            raise ValueError("unknown metadata chunk %r" % type)

    print("section 1 ends at %d" % f.fh.tell())

    # link sub-section

    links_start = f.fh.tell()
    links_end = f.fh.tell() + exp_links_bytes

    while f.fh.tell() < links_end:
        print("--- links [%d] ---" % f.fh.tell())
        type = f.read(1)
        if None:
            pass
        elif type == b"\x00":
            # <option> selections
            f.read(1)
            n = f.read_byte()
            for j in range(n):
                f.read_string()
                f.read_string()
        elif type == b"i":
            # shared 'region' format
            n = f.read_byte()
            boxes = []
            for j in range(n):
                pos = f.read_coords()
                size = f.read_coords()
                boxes.append((pos, size))
            if version >= 15:
                img_url = f.read_url()
                assert(f.read(2) == b"\x01t")
                img_type = f.read_string()
            elif version == 13:
                img_url = f.read_url()
                f.read(2)
                img_type = f.read_string()
            elif version == 12:
                img_type = f.read_string()
                img_url = f.read_url()
            for pos, size in boxes:
                yield {"_type": "image",
                       "src": img_url,
                       "type": img_type,
                       "pos": pos,
                       "size": size}
        elif type in {b"L", b"P"}:
            # shared 'region' format, except for "L"/v12
            n = f.read_byte()
            if version == 12:
                f.read(2)
            boxes = []
            for j in range(n):
                pos = f.read_coords()
                size = f.read_coords()
                boxes.append((pos, size))
            if version >= 15:
                link_url = f.read_url()
                assert(f.read(2) == b"\x01t")
                link_type = f.read_string()
            elif version == 13:
                link_url = f.read_url()
                f.read(2)
                link_type = f.read_string()
            elif version == 12:
                link_url = f.read_url()
                link_type = ""
            if not link_url.startswith("b:"):
                for pos, size in boxes:
                    yield {"_type": "link",
                           "href": link_url,
                           "type": link_type,
                           "pos": pos,
                           "size": size}
        elif type in {b"C", b"I", b"N", b"S", b"w", b"W"} and version >= 15:
            # shared 'region' format
            n = f.read_byte()
            for j in range(n):
                pos = f.read_coords()
                size = f.read_coords()
            f.read_blob()
            assert(f.read(2) == b"\x01t")
            f.read_blob()
        elif type in {b"S"} and version == 13:
            # shared 'region' format
            n = f.read_byte()
            for j in range(n):
                pos = f.read_coords()
                size = f.read_coords()
            f.read_blob()
            f.read(2)
            f.read_blob()
        elif type == b"C" and version == 12:
            f.read(24)
        elif type in {b"I", b"S", b"W"} and version == 12:
            # shared 'region' format
            n = f.read_byte()
            for j in range(n):
                pos = f.read_coords()
                size = f.read_coords()
            f.read_blob()
            f.read_blob()
        else:
            raise ValueError("unknown link chunk %r/v%r" % (type, version))

    print("section 2 ends at %d" % f.fh.tell())
    if f.fh.tell() != links_end:
        raise ValueError("link section ended at %d, expected %d" % (f.fh.tell(), links_end))

    # content section

    content_start = f.fh.tell()
    content_end = exp_total_bytes

    while f.fh.tell() < content_end:
        print("--- content [%d] ---" % f.fh.tell())
        type = f.read(1)
        if None:
            pass
        elif type == b"o":
            if version >= 15:
                # TODO: not sure if actual type or just part of preceding "I"-block
                f.read_blob()
            else:
                raise ValueError("unhandled content chunk %r/v%r" % (type, version))
        elif type == b"B":
            if version >= 15:
                pos = f.read_coords(rel_to_abs=True)
                size = f.read_coords()
                color = f.read_color()
            else:
                pos = f.read_coords()
                size = f.read_coords()
                color = f.read_color()
            yield {"_type": "box",
                   "pos": pos,
                   "size": size,
                   "fill": color}
        elif type == b"F":
            f.read(16)
            f.read_blob()
            f.read_blob()
            if version >= 15:
                f.read(5)
            else:
                f.read(3)
        elif type == b"I":
            if version == 16:
                pos = f.read_coords(rel_to_abs=True)
                size = f.read_coords()
                color = f.read_color()
                f.read(11)
            elif version == 15:
                pos = f.read_coords(rel_to_abs=True)
                size = f.read_coords()
                color = f.read_color()
                f.read(14)
            else:
                pos = f.read_coords()
                size = f.read_coords()
                color = f.read_color()
                f.read(6)
            yield {"_type": "box",
                   "pos": pos,
                   "size": size,
                   "fill": color}
        elif type == b"L":
            f.read(9)
        elif type == b"M":
            f.read(2)
            f.read_blob()
        elif type == b"S":
            exp_files_bytes = f.read_medium()
            files_start = f.fh.tell()
            files_end = f.fh.tell() + exp_files_bytes
            while f.fh.tell() < files_end:
                buf = f.read_blob()
                yield {"_type": "file",
                       "data": buf[:16]+b"..."}
            print("files started at %d, ends at %d" % (files_start, f.fh.tell()))
            if f.fh.tell() != files_end:
                raise ValueError("content.files section ended at %d, expected %d" % (f.fh.tell(), files_end))
        elif type == b"T":
            if version == 16:
                pos = f.read_coords(rel_to_abs=True)
                size = f.read_coords()
                color = f.read_color()
                f.read(1)
                font = 4 | (f.read_byte() & 1)
                n = f.read_byte()
                for j in range(n):
                    print("text link", f.read(1), f.read_blob())
                text = f.read_string()
            elif version == 15:
                pos = f.read_coords(rel_to_abs=True)
                size = f.read_coords()
                color = f.read_color()
                font = f.read_byte()
                text = f.read_string()
            else:
                pos = f.read_coords()
                size = f.read_coords()
                color = f.read_color()
                font = f.read_byte()
                text = f.read_string()
            yield {"_type": "text",
                   "text": text,
                   "font": font,
                   "color": color,
                   "pos": pos,
                   "size": size}
        else:
            raise ValueError("unknown content chunk %r/v%r" % (type, version))

    print("section 3 started at %d, ends at %d" % (content_start, f.fh.tell()))
    if f.fh.tell() != content_end:
        raise ValueError("content section ended at %d, expected %d" % (f.fh.tell(), content_end))

font_sizes = {
    0: "11px", # medium
    2: "12px", # large
    4: "13px", # extra large
    6: "10px", # small
}

for arg in sys.argv[1:]:
    with open("%s.html" % arg, "w") as fout:
        fout.write('<!DOCTYPE html>\n')
        fout.write('<meta charset="utf-8">\n')
        fout.write('<style>\n')
        fout.write('.box { z-index: -100; }\n')
        fout.write('.img { z-index: -50; }\n')
        fout.write('.link { z-index: 100; }\n')
        fout.write('.link:hover { outline: 1px solid blue; }\n')
        fout.write('</style>\n')
        for item in parse_file(arg):
            type = item["_type"]
            pprint(item)
            if type == "head":
                fout.write('<!-- origin: %s -->\n' % item["url"])
                fout.write('<title>%s</title>\n' % item["title"])
            elif type == "text":
                item_x, item_y = item["pos"]
                font_size = item["font"] & ~1
                font_weight = item["font"] & 1
                style = [
                    "white-space: pre",
                    "font-family: sans-serif",
                    "font-size: %s" % font_sizes[font_size],
                    "font-weight: %s" % ("bold" if font_weight else "normal"),
                    "line-height: 1.1",
                    "color: %s" % rgba(item["color"]),
                    "position: absolute",
                    "left: %dpx" % item_x,
                    "top: %dpx" % item_y,
                ]
                if "size" in item:
                    style += [
                        "width: %dpx" % item["size"][0],
                        "height: %dpx" % item["size"][1],
                        #"outline: 1px dotted %s" % rgba(item["color"]),
                    ]
                style = "; ".join(style)
                fout.write('<div class="item text" style="%s">' % style)
                fout.write(item["text"])
                fout.write('</div>\n')
            elif type == "image":
                item_x, item_y = item["pos"]
                item_w, item_h = item["size"]
                repeat = True
                style = [
                    "background-image: url('%s')" % item["src"],
                    "position: absolute",
                    "left: %dpx" % item_x,
                    "top: %dpx" % item_y,
                    "width: %dpx" % item_w,
                    "height: %dpx" % item_h,
                ]
                style = "; ".join(style)
                if repeat:
                    fout.write('<div class="item img" style="%s"></div>\n' % style)
                else:
                    fout.write('<img class="item img" src="%s" style="%s">\n' % (item["src"], style))
            elif type == "box":
                item_x, item_y = item["pos"]
                item_w, item_h = item["size"]
                style = [
                    "background-color: %s" % rgba(item["fill"]),
                    "position: absolute",
                    "left: %dpx" % item_x,
                    "top: %dpx" % item_y,
                    "width: %dpx" % item_w,
                    "height: %dpx" % item_h,
                ]
                style = "; ".join(style)
                fout.write('<div class="item box" style="%s"></div>\n' % style)
            elif type == "link":
                item_x, item_y = item["pos"]
                item_w, item_h = item["size"]
                style = [
                    "position: absolute",
                    "left: %dpx" % item_x,
                    "top: %dpx" % item_y,
                    "width: %dpx" % item_w,
                    "height: %dpx" % item_h,
                    "display: block",
                ]
                style = "; ".join(style)
                fout.write('<a class="item link" href="%s" style="%s"></a>\n' % (item["href"], style))
            elif type == "file":
                # look up mimetype from last 'i' item
                # look up <img> tag from last "image"
                pass
