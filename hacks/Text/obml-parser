#!/usr/bin/env python
# A barebones parser for OBML files used by Opera Mini
#
# Originally intended to extract original URLs from saved pages, after Opera dropped
# binary compatibilty between minor releases and left me with a bunch of unreadable
# saved pages in v15 â€” and it does that.

import base64
import os
import struct
import sys

class Parser():
    def __init__(self, path):
        self.path = path
        self.fh = open(path, 'rb')
        self.url_base = "\0"

    def debug(self, typ, data):
        if os.environ.get("DEBUG"):
            print("\033[33m", "#", typ, repr(data), "\033[m")
        return data

    def read(self, length):
        buf = self.fh.read(length)
        if len(buf) < length:
            raise IOError("Hit EOF after %d/%d bytes" % (len(buf), length))
        return self.debug("raw[%d]" % length, buf)

    def read_byte(self):
        length = 1
        buf = self.fh.read(length)
        if len(buf) < length:
            raise IOError("Hit EOF after %d/%d bytes" % (len(buf), length))

        data, = struct.unpack('>B', buf)
        return self.debug("byte", data)

    def read_short(self):
        length = 2
        buf = self.fh.read(length)
        if len(buf) < length:
            raise IOError("Hit EOF after %d/%d bytes" % (len(buf), length))

        data, = struct.unpack('>H', buf)
        return self.debug("short", data)

    def read_chunk(self):
        length = self.read_short()
        buf = self.fh.read(length)
        if len(buf) < length:
            raise IOError("Hit EOF after %d/%d bytes" % (len(buf), length))

        return self.debug("chunk[%d]" % length, buf)

    def read_string(self):
        buf = self.read_chunk()
        buf = buf.decode('utf-8')
        return self.debug("-> str[%d]" % len(buf), buf)

    def read_url(self, base=None):
        buf = self.read_string()
        if buf and buf[0] == "\0":
            if not base:
                base = self.url_base
            buf = base + buf[1:]
        return self.debug("-> url[%d]" % len(buf), buf)

def infinity(start=0):
    i = start
    while True:
        yield i
        i += 1

def strhex(buf):
    return " ".join(["%02X" % x for x in buf])

def parse_file(arg):
    print("file =", arg)

    f = Parser(arg)

    # alwyas 02 D3 55 10 ?? ?? ??
    magic = f.read(4)
    if magic == b'\x02\xd3\x55\x10':
        magic += f.read(3)
        print("unknown 1 =", strhex(magic))
        version = f.read_byte()
        print("version =", version)

        if version == 16:
            # always 00 F0 ?? ?? ??
            magic = f.read(5)
            # always FF FF
            magic += f.read(2)
            print("unknown 2 =", strhex(magic))
        else:
            raise ValueError('unknown version %d' % version)

        page_title = f.read_string()
        f.read_chunk() # nil on v16, 'C\x10\x10...' on v15
        page_urlbase = f.read_string()
        f.url_base = page_urlbase
        page_url = f.read_url()
        print("title =", page_title)
        print("url =", page_url)

        f.read(6)

        # section 1 - unknown data

        for i in infinity(start=1):
            print("-- section 1 item %d --" % i)
            type = f.read(1)
            if type == b"M":
                f.read(2)
                f.read_chunk()
            elif type == b"S":
                f.read(1)
                f.read(2)
                print("end of unknown section")
                break
            else:
                f.read(64)
                raise ValueError("in unknown section, unknown type %r" % type)

        # section 2 - links and stuff

        for i in infinity(start=1):
            print("-- section 2 item %d --" % i)
            type = f.read(1)
            if None:
                pass
            elif type == b"\x00":
                f.read(10)
            elif type == b"i":
                # "i" image
                n = f.read_byte()
                for j in range(n):
                    f.read(10)
                img_url = f.read_url()
                f.read(2)
                img_type = f.read_string()
                print("image =", img_url)
            elif type in {b"L", b"P"}:
                # "L" link
                # "P" ??? (usually mailto link)
                n = f.read_byte()
                for j in range(n):
                    f.read(10)
                if n == 0:
                    # unknown trailer
                    # \x00\xe7\x00\x00\xe7\x00\x05\x40
                    # \x01\x8a\x00\x01\x8a\x00\x04\x39
                    f.read(8)
                    # end of link section
                    break
                else:
                    link_url = f.read_url()
                    f.read(2)
                    link_type = f.read_string()
                    if not link_url.startswith("b:"):
                        print("link =", link_url)
            elif type in {b"I", b"N", b"S", b"w", b"W"}:
                n = f.read_byte()
                if n != 1:
                    raise ValueError("in type %r, unexpected count %d" % (type, n))
                for j in range(n):
                    f.read(10)
                f.read_chunk()
                f.read(2)
                f.read_chunk()
            else:
                f.read(64)
                raise ValueError("in link section, unknown type %r" % type)

        # section 3 - content

        print("=== content ===")
        for i in infinity(start=1):
            print("-- content %d --" % i)
            type = f.read(1)
            if None:
                pass
            elif type == b"o":
                # TODO: not sure if actual type or just part of preceding "I"-block
                f.read_chunk()
            elif type == b"B":
                f.read(14)
            elif type == b"F":
                f.read(16)
                f.read_chunk()
                f.read_chunk()
                f.read(5)
            elif type == b"I":
                f.read(25)
            elif type == b"M":
                f.read(2)
                f.read_chunk()
            elif type == b"S":
                f.read(3)
                while True:
                    print(">> S-chunk", j+2)
                    f.read_chunk()
            elif type == b"T":
                # text block
                f.read(16)
                n = f.read_byte()
                for j in range(n):
                    f.read(5)
                buf = f.read_string()
                if n:
                    print("text link?[%d] =" % n, buf)
                else:
                    print("text =", buf)
            else:
                f.read(1024)
                raise ValueError("in content section, unknown type %r" % type)

            if i > 1000:
                print("! limit reached"); return

    elif magic == b'\x02\xce\x9a\x0c' \
      or magic == b'\x00\xe5\xfd\x0c' \
      or magic == b'\x00\xe6\x18\x0c' \
      or magic == b'\x01\x39\xb9\x0c':
        f.read(10)
        page_title = f.read_string()
        f.read_chunk() # nil
        page_urlbase = f.read_string()
        f.url_base = page_urlbase
        page_url = f.read_url()
        print("title =", page_title)
        print("url =", page_url)
        print()

        f.read(5)

        for i in infinity(start=1):
            print("--- section 1 item %d ---" % i)
            type = f.read(1)
            if None:
                pass
            elif type == b"M":
                f.read(2)
                f.read_chunk()
            elif type == b"S":
                f.read(1)
                buf = f.read(2)
                # TODO: figure out the damn pattern
                if buf == b'\x05\xa1':
                    nj = 0
                elif buf == b'#y':
                    nj = 2
                elif buf == b'!\xe3':
                    nj = 2
                elif buf == b'&\xdd':
                    nj = 2
                else:
                    nj = 0
                for j in range(nj):
                    print("??")
                    f.read(2)
                    nk = f.read_byte()
                    for k in range(nk):
                        f.read_string()
                        f.read_string()
                #f.read(512)
                break
            else:
                f.read(1024)
                raise ValueError("in header section, unknown type %r" % type)

        for i in infinity(start=1):
            print("--- section 2 item %d ---" % i)
            type = f.read(1)
            if None:
                pass
            elif type == b"i":
                n = f.read_byte()
                for j in range(n):
                    f.read(10)
                img_type = f.read_string()
                img_url = f.read_url()
                print("image =", img_url)
            elif type == b"C":
                f.read(24)
            elif type == b"I":
                n = f.read_byte()
                for j in range(n):
                    f.read(10)
                f.read_chunk()
                f.read_chunk()
            elif type == b"L":
                n = f.read_byte()
                if n == 0:
                    f.read(8)
                    break
                elif 1 <= n <= 5:
                    f.read(2)
                    for j in range(n):
                        f.read(10)
                    link_url = f.read_url()
                    print("link =", link_url)
                else:
                    f.read(1024)
                    raise ValueError("in %r item, unexpected n=%d" % (type, n))
            elif type == b"S":
                n = f.read_byte()
                for j in range(n):
                    f.read(10)
                f.read_string()
                f.read_string()
            elif type == b"W":
                n = f.read_byte()
                for j in range(n):
                    f.read(10)
                f.read_string()
                f.read_string()
            else:
                f.read(1024)
                raise ValueError("in link section, unknown type %r" % type)

        for i in infinity(start=1):
            print("--- section 2 item %d ---" % i)
            type = f.read(1)
            if None:
                pass
            elif type == b"B":
                f.read(1)
                f.read(13)
            elif type == b"F":
                f.read(16)
                f.read_chunk()
                f.read_chunk()
                f.read(3)
            elif type == b"I":
                f.read(20)
            elif type == b"S":
                f.read(3)
                while True:
                    try:
                        f.read_chunk()
                    except OSError as e:
                        return
            elif type == b"T":
                f.read(15)
                f.read_chunk()
            else:
                f.read(1024)
                raise ValueError("in content section, unknown type %r" % type)
    else:
        print("error = unrecognized OBML format")

for arg in sys.argv[1:]:
    parse_file(arg)
