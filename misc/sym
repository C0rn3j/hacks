#!/usr/bin/env perl
# sym - create relative symlinks
# (Released under WTFPL v2 <http://sam.zoy.org/wtfpl/>)
use warnings;
use strict;
use Cwd qw(realpath);
use File::Basename;
use File::Spec;
use Getopt::Long qw(:config bundling no_ignore_case);

BEGIN {
	if (eval {require Nullroute::Lib}) {
		Nullroute::Lib->import(qw(_debug _warn _err _die));
	} else {
		our ($arg0, $warnings, $errors);
		$::arg0 = basename($0);
		sub _debug { warn "debug: @_\n" if $ENV{DEBUG}; }
		sub _warn  { warn "warning: @_\n"; ++$::warnings; }
		sub _err   { warn "error: @_\n"; ! ++$::errors; }
		sub _die   { _err(@_); exit 1; }
	}
}

my $force = 0;
my $verbose = 0;
my $dest;
my $realpath = 0;

=item my_abs_path($path)

Canonicalize symlinks and relative paths.
If $path itself is a symlink, do not canonicalize it.

=cut

sub my_abs_path {
	my ($path) = @_;
	realpath(dirname($path))."/".basename($path);
}

sub do_link {
	my ($target, $link) = @_;
	$verbose && print "'$link' -> '$target'\n";
	if (-l $link or -e $link) {
		if ($force) {
			unlink($link);
			symlink($target, $link) or _warn("could not create symlink: $!");
		} else {
			_err("$link: already exists");
		}
	} else {
		symlink($target, $link) or _warn("could not create symlink: $!");
	}
}

sub collapse {
	my ($path) = @_;
	my @path = File::Spec->splitdir($path);
	my @out;
	for (@path) {
		if ($_ eq "..")    { pop @out; }
		elsif ($_ eq ".")  { next; }
		else               { push @out, $_; }
	}
	File::Spec->catdir("", @out);
}

sub usage {
	print "$_\n" for
	"Usage: $::arg0 [-f] TARGET LINKNAME",
	"       $::arg0 [-f] TARGET... DIRECTORY",
	"       $::arg0 -r FILE...  ('realpath' emulation)",
	"       $::arg0 -rr FILE... ('realpath -m' emulation)";
}

# Option parsing

GetOptions(
	"help"			=> sub { usage(); exit; },
	"f|force!"		=> \$force,
	"r|realpath+"		=> \$realpath,
	"t|target-directory=s"	=> \$dest,
	"v|verbose!"		=> \$verbose,
) or exit 2;

# Main code (realpath mode)

if ($realpath > 1) {
	# `/usr/bin/realpath -m` emulation mode
	for my $file (@ARGV) {
		my $real = realpath($file);
		if (!defined $real) {
			if (-l $file) {
				$file = readlink($file);
				if (!defined $file) {
					_err("readlink: '$file': $!");
					next;
				}
			}
			$real = File::Spec->rel2abs($file);
			$real = collapse($real);
		}
		print "$real\n";
	}
	exit !!$::errors;
}
elsif ($realpath > 0) {
	# `/usr/bin/realpath` emulation mode
	for my $file (@ARGV) {
		my $real = realpath($file);
		if (!defined $real) {
			_err("realpath: '$file': $!");
			next;
		}
		print "$real\n";
	}
	exit !!$::errors;
}

# Main code (normal mode)

if (!defined $dest) {
	$dest = (@ARGV > 1) ? pop @ARGV : ".";
}

if (!@ARGV) {
	_die("missing link target", 2);
}

$dest = my_abs_path($dest);

if (!defined $dest) {
	_die("target does not exist");
} elsif (-d $dest) {
	# target [target...] dest_dir
	_debug("dest=$dest");
	for my $target (@ARGV) {
		_debug("target=$target");
		my $reltarget = File::Spec->abs2rel($target, $dest);
		_debug("    reltarget=$reltarget");
		my $link = File::Spec->catfile($dest, basename($target));
		_debug("    link=$link");
		do_link($reltarget, $link);
	}
} else {
	# target dest
	if (@ARGV > 1) {
		_die("target is not a directory");
	}
	_debug("dest=$dest");
	my $target = pop(@ARGV);
	_debug("target=$target");
	my $reltarget = File::Spec->abs2rel($target, dirname($dest));
	_debug("    reltarget=$reltarget");
	do_link($reltarget, $dest);
}

exit !!$::errors;
