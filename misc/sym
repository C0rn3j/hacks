#!/usr/bin/env perl
# sym - create relative symlinks
# (Released under WTFPL v2 <http://sam.zoy.org/wtfpl/>)
use warnings;
use strict;
use Cwd qw(realpath);
use File::Basename;
use File::Spec;
use Getopt::Long qw(:config bundling no_ignore_case);

BEGIN {
	if (eval {require Nullroute::Lib}) {
		Nullroute::Lib->import(qw(_debug _warn _err _die));
	} else {
		our ($arg0, $warnings, $errors);
		$::arg0 = basename($0);
		sub _debug { warn "debug: @_\n" if $ENV{DEBUG}; }
		sub _warn  { warn "warning: @_\n"; ++$::warnings; }
		sub _err   { warn "error: @_\n"; ! ++$::errors; }
		sub _die   { _err(@_); exit 1; }
	}
}

my $force = 0;
my $verbose = 0;
my $link_dir;
my $realpath = 0;

sub collapse {
	my ($path) = @_;
	my @path = File::Spec->splitdir($path);
	my @out;
	for (@path) {
		if ($_ eq "..")    { pop @out; }
		elsif ($_ eq ".")  { next; }
		else               { push @out, $_; }
	}
	File::Spec->catdir("", @out);
}

sub do_link {
	my ($target, $link) = @_;
	print "'$link' -> '$target'\n" if $verbose;

	if ($force && (-l $link || -e $link)) {
		_debug("removing existing \"$link\"");
		unlink($link) or return _err("could not remove \"$link\": $!");
	}

	_debug("creating \"$link\" (target: \"$target\")");
	symlink($target, $link) or return _err("could not create \"$link\": $!");
}

sub usage {
	print "$_\n" for
	"Usage: $::arg0 [-f] TARGET LINKNAME",
	"       $::arg0 [-f] TARGET... DIRECTORY",
	"       $::arg0 -r FILE...  ('realpath' emulation)",
	"       $::arg0 -rr FILE... ('realpath -m' emulation)";
}

# Option parsing

GetOptions(
	"help"			=> sub { usage(); exit; },
	"f|force!"		=> \$force,
	"r|realpath+"		=> \$realpath,
	"t|target-directory=s"	=> \$link_dir,
	"v|verbose!"		=> \$verbose,
) or exit 2;

# Main code (realpath mode)

if ($realpath > 1) {
	# `/usr/bin/realpath -m` emulation mode
	for my $file (@ARGV) {
		my $real = realpath($file);
		if (!defined $real) {
			if (-l $file) {
				$file = readlink($file);
				if (!defined $file) {
					_err("readlink: '$file': $!");
					next;
				}
			}
			$real = File::Spec->rel2abs($file);
			$real = collapse($real);
		}
		print "$real\n";
	}
	exit !!$::errors;
}
elsif ($realpath > 0) {
	# `/usr/bin/realpath` emulation mode
	for my $file (@ARGV) {
		my $real = realpath($file);
		if (!defined $real) {
			_err("realpath: '$file': $!");
			next;
		}
		print "$real\n";
	}
	exit !!$::errors;
}

# Main code (normal mode)

if (defined $link_dir) {
	_debug("link directory: \"$link_dir\"");

	if (!-d $link_dir) {
		_die("destination \"$link_dir\" is not a directory");
	}

	if (!@ARGV) {
		_die("missing link target(s)");
	}

	for my $target (@ARGV) {
		my $abs_target;
		my $rel_target;
		my $link_name;

		_debug("* argument: \"$target\"");
		$abs_target = File::Spec->rel2abs($target);
		_debug("  - absolute: \"$abs_target\"");
		$rel_target = File::Spec->abs2rel($target, $link_dir);
		_debug("  - relative: \"$rel_target\"");
		$link_name = File::Spec->catfile($link_dir, basename($target));
		_debug("  link name: \"$link_name\"");

		do_link($rel_target, $link_name);
	}
} else {
	my $link_dest = pop(@ARGV) // ".";

	if (!@ARGV) {
		_die("missing link target(s)");
	}

	if (-d $link_dest || $link_dest =~ m|/$|) {
		$link_dir = $link_dest;
	} else {
		if (@ARGV > 1) {
			_die("destination \"$link_dest\" is not a directory");
		}
		$link_dir = dirname($link_dest);
	}

	for my $target (@ARGV) {
		my $abs_target;
		my $rel_target;
		my $link_name;

		_debug("* argument: \"$target\"");
		$abs_target = File::Spec->rel2abs($target);
		_debug("  - absolute: \"$abs_target\"");
		$rel_target = File::Spec->abs2rel($target, $link_dir);
		_debug("  - relative: \"$rel_target\"");
		$link_name = File::Spec->catfile($link_dir, basename($target));
		_debug("  link name: \"$link_name\"");

		do_link($rel_target, $link_name);
	}
}

exit !!$::errors;
