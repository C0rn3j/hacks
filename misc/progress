#!/usr/bin/env perl
# progress - summarize line-based stdout to one dynamic progress line
use warnings;
use strict;
use POSIX qw(ceil);


my ($width, $count, $last);
my $last_lines = 0;

sub status {
	my ($msg, $fmt) = @_;
	my $out = "";
	$out .= "\e[".($last_lines-1)."A" if $last_lines > 1; # cursor up
	$out .= "\e[1G"; # cursor to column 1
	$out .= "\e[0J"; # erase below
	$out .= sprintf($fmt // "%s", $msg);
	$last_lines = ceil(length($msg) / $width);
	print $out;
}

$| = 1;

$width = int(`stty size </dev/tty | awk '{print \$2}'`);
$count = 0;
$last = time;

$SIG{INT} = sub {
	status("$count items (interrupted)", "%s\n");
	exit 1;
};

while (++$count, my $str = <STDIN>) {
	my ($now, $pre);

	$now = time;
	next if $now - $last < 1;
	$last = $now;

	chomp($str);
	status("$count $str", "\e[33m$count\e[m $str");
}

status("$count items", "%s\n");
