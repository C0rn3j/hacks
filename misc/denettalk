#!/usr/bin/env python3
# denettalk - bruteforce Nettalk's "NTCTC001" encrypted messages
# (ported from Haskell version at <http://lpaste.net/85305>)

import sys, re

codeChr = "0123456789abcdefghijklmnopqrstuvwxyz!?#%-+"
multPl = 71

def decrypt(tpass, msg):
    def go(i, lastCVal, rest):
        if len(rest) < 2:
            return ""
        c1, c2, *rest = rest
        i1 = codeChr.find(c1)
        i2 = codeChr.find(c2)
        charVal = (i2 * 42 + i1 - tpass + multPl * i - lastCVal * (13 + i * 7)) % 1764
        return chr(charVal % 256) + go(i+1, i2+1, rest)
    return go(1, 0, msg[10:])

def try_all(enc):
    for key in range(1764):
        msg = decrypt(key, enc)
        if msg.endswith("<>"):
            yield msg[:-2]

def hax0r(enc):
    from collections import defaultdict

    # sometimes up to 10 different keys may work â€“ most of them will decrypt to
    # the correct plaintext, others will decrypt ~80% correctly but have
    # garbage in some places; so try all keys but return only the version that
    # occurs most often.

    variants = defaultdict(int)
    for msg in try_all(enc):
        variants[msg] += 1

    variants = list(variants.items())
    variants.sort(key=lambda x: x[1])

    yield variants[-1][0]
    #variants.reverse()
    #return ["%s (%d)" % x for x in variants]

def is_printable(s):
    return all(32 <= ord(c) <= 127 or c in '\t' for c in s)

def escaped(s):
    return repr(s)[1:-1]

rx = re.compile(r"\[NTCTC001\|(.+?)\]")

if len(sys.argv) > 1:
    # decrypt arguments
    for line in sys.argv[1:]:
        m = rx.search(line)
        if m:
            for msg in hax0r(m.group(0)):
                print(line[:m.start(0)] + escaped(msg) + line[m.end(0):])
else:
    # act as a filter
    for line in sys.stdin:
        line = line.strip()
        m = rx.search(line)
        if m:
            print("-", line)
            for msg in hax0r(m.group(0)):
                print("+", line[:m.start(0)] + escaped(msg) + line[m.end(0):])
        else:
            print(" ", line)
