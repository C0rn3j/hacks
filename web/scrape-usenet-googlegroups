#!/usr/bin/env perl
use feature "say";

use Data::Dumper;
use File::Temp;
use HTML::TreeBuilder;
use HTTP::Cookies;
use LWP::ConnCache;
use LWP::UserAgent;
use URI;

my $ua = LWP::UserAgent->new;
$ua->agent("Mozilla/4.0");
$ua->conn_cache(LWP::ConnCache->new);
$ua->cookie_jar(HTTP::Cookies->new(file => "gg-cookies.txt", autosave => 1));
$ua->timeout(15);
$ua->show_progress(1);

my $x11_prompter = "$ENV{HOME}/code/x11/ask-captcha";

our $gg_utoken;

sub ui_captcha_prompt {
	my ($img_url) = @_;
	my $response;
	if (defined $ENV{DISPLAY} && -x $x11_prompter) {
		my $tmp = File::Temp->new;
		my $req = $ua->get($img_url, ":content_file" => $tmp->filename);

		open(my $proc, "-|", $x11_prompter, $tmp->filename);
		chomp($response = <$proc>);
		close($proc);
	} else {
		say STDERR "Challenge: $img_url";
		print STDERR "Response: ";
		chomp($response = <STDIN>);
	}
	return $response;
}

sub follow_redirect {
	my ($url) = @_;
	my $req = $ua->head($url);
	if ($req->is_success) {
		return $req->request->uri;
	} else {
		return undef;
	}
}

sub gg_follow_redirect {
	my ($msgid) = @_;
	my $msgid_url = "http://groups.google.com/groups?selm=$msgid";
	my $final_url = follow_redirect($msgid_url);
	if ($final_url ~~ m|//groups\.google\.com/group/([^/]+)/msg/(\w+)|) {
		my ($group, $mhash) = ($1, $2);
		return ($group, $mhash);
	} else {
		return undef;
	}
}

sub gg_get_path {
	my ($group, $mhash) = @_;
	return "/group/$group/msg/$mhash";
}

sub gg_get_raw_url {
	our $gg_utoken;
	my ($group, $mhash) = @_;
	my $path = gg_get_path($group, $mhash);
	my $url = "http://groups.google.com$path?dmode=source&output=gplain";
	if ($gg_utoken) {
		$url .= "&utoken=$gg_utoken";
	}
	return $url;
}

sub gg_unlock_article {
	my ($group, $mhash) = @_;
	my $path = gg_get_path($group, $mhash);
	my $interact_url = URI->new("http://groups.google.com/groups/unlock?_done=$path&msg=$mhash");

	while (1) {
		my ($req, $html, $tree);
		$req = $ua->get($interact_url);
		$html = $req->decoded_content;
		$tree = HTML::TreeBuilder->new;
		$tree->parse_content($html);

		# find CAPTCHA image
		my ($captcha_t) = $tree->look_down(_tag => "img", src => qr/token/);
		my $captcha_url = URI->new_abs($captcha_t->attr("src"), $interact_url);
		my $response = ui_captcha_prompt($captcha_url);

		# fill and submit the form
		my ($form_t) = $tree->look_down(_tag => "form", action => qr/verify_captcha/);
		my %query = map {$_->attr("name") => $_->attr("value")}
				$form_t->look_down(_tag => "input");
		$query{answer} = $response;

		my $action_url = URI->new_abs($form_t->attr("action"), $interact_url);
		$action_url->query_form(\%query);

		my $redirect_url = follow_redirect($action_url);
		my %params = $redirect_url->query_form;
		if ($params{utoken}) {
			$gg_utoken = $params{utoken};
			say "Unlocked: utoken = $gg_utoken";
			return $gg_utoken;
		} elsif ($params{retry}) {
			say "Unlock failed.";
			next;
		} else {
			say "Redirected to hell knows where:";
			say "  $redirect_url";
			exit 1;
		}
	};
}

sub gg_needs_unlock {
	my ($article) = @_;
	if ($article ~~ /^From:.+\.\.\.\@/mi) {
		$gg_utoken = undef;
		return 1;
	} else {
		return 0;
	}
}

sub gg_fetch_article {
	my ($group, $mhash) = @_;
	my $article;
	do {
		if (!$gg_utoken) {
			$gg_utoken = gg_unlock_article($group, $mhash);
		}
		my $raw_url = gg_get_raw_url($group, $mhash);
		my $req = $ua->get($raw_url);
		$article = $req->decoded_content;
		$article =~ s/^\s+\n//;
	} while (gg_needs_unlock($article));
	return $article;
}

for my $msgid (@ARGV) {
	my ($group, $mhash) = gg_follow_redirect($msgid);
	say "Downloading $group--$mhash";

	my $article = gg_fetch_article($group, $mhash);
	say for grep {s/^/    /}
		grep {/^(From|Date|Message-ID|Subject):/i}
		split(/\n/, $article);

	my $file = "usenet.$group--$mhash.msg";
	if (open my $fh, ">", $file) {
		print $fh $article;
		close $fh;
		say "Stored $msgid to $file";
	}
}
