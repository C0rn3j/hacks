#!/usr/bin/python
import os, sys
import shutil
from math import ceil, log10

bold = lambda text: "\033[1m%s\033[m" % text

local_root = os.path.expanduser("~/music")
remote_root = os.path.expanduser("/media/DRIZZLE/Music")

def scan(root):
	for dirpath, dirs, files in os.walk(root):
		for name in files:
			absfile = os.path.join(dirpath, name)
			relfile = os.path.relpath(absfile, root)
			yield relfile, os.stat(absfile)

def find_newer(a, b):
	for name in a.keys():
		try:
			atime, btime = a[name].st_mtime, b[name].st_mtime
		except KeyError:
			continue
		if atime-2 > btime:
			yield name

def escape_arg(arg):
	return arg.\
		replace('$', '\\$').\
		replace('"', '\\"').\
		replace('`', '\\`').\
		replace('\\', '\\\\')

def ask(question, path, preans=None):
	msg = "%s: %s: " % (bold(question), path)

	sys.stdout.write(msg)
	if preans:
		sys.stderr.write(preans+"\n")
	sys.stderr.flush()
	return preans or sys.stdin.readline().strip()

def unitPrefix(size):
	prefixes = "kMGTPEZYH"
	scale = 0
	while size >= 1024 and scale < len(prefixes):
		size /= 1024.
		scale += 1
	return size, prefixes[scale-1] if scale else None

def formatSize(size, precision=1):
	size, prefix = unitPrefix(size)
	fsize = "%.*f" % (precision, size)
	if prefix:
		return "%s%s" % (fsize, prefix)
	else:
		return fsize

def mkdir(path):
	comps = []
	tail = True
	head = path
	while tail:
		head, tail = os.path.split(head)
		comps.append(tail)
	comps.reverse()
	for tail in comps:
		path = os.path.join(head, tail)
		if not os.path.isdir(path):
			print "mkdir:", path
			os.mkdir(path)
		head = path

def file_copy(source, target):
	BUFSIZE = 2*1024*1024

	mkdir(os.path.dirname(target))
	infd = open(source, "rb")
	outfd = open(target, "wb")

	instat = os.stat(source)
	os.utime(target, (0, 0))

	while True:
		buf = infd.read(BUFSIZE)
		if not buf:
			break
		outfd.write(buf)
		yield outfd.tell()

	os.utime(target, (instat.st_mtime, instat.st_mtime))
	infd.close()
	outfd.close()

def run_queue(actions):
	fmt_prefix	= "%(item)s \033[35m%(direction)s\033[m "
	fmt_copy	= "\033[32m%(progress)3d%%\033[m %(path)s"
	fmt_delete	= "\033[31m(del)\033[m %(path)s"

	actions.sort(key=lambda x: (x[1], x[0], x[2]))
	w_item = int(ceil(log10(len(actions))))
	for i, (action, target, path) in enumerate(actions):
		item = "%*d/%d" % (w_item, i+1, len(actions))

		if target == "local":
			# local <-- remote
			source, direction = "remote", "<--"
			src = os.path.join(remote_root, path)
			dst = os.path.join(local_root, path)
		else:
			# local --> remote
			source, direction = "local", "-->"
			src = os.path.join(local_root, path)
			dst = os.path.join(remote_root, path)
		
		if action == "copy":
			instat = os.stat(src)
			for pos in file_copy(src, dst):
				progress = (pos*100 / instat.st_size)
				sys.stdout.write("\r" + (fmt_prefix+fmt_copy) % locals())
				sys.stdout.flush()
			sys.stdout.write("\n")

		elif action == "delete":
			sys.stdout.write((fmt_prefix+fmt_delete) % locals() + "\n")
			os.unlink(dst)

def sync():
	local = dict(scan(local_root))
	remote = dict(scan(remote_root))

	local_names = set(local.keys())
	remote_names = set(remote.keys())

	local_only = local_names - remote_names
	remote_only = remote_names - local_names

	diffsize = [path for path in (local_names & remote_names)
		if local[path].st_size != remote[path].st_size]

	actions = []

	print 'local="%s"' % escape_arg(local_root)
	print 'remote="%s"' % escape_arg(remote_root)

	Ans = None
	for path in sorted(find_newer(local, remote)):
		ans = ask("local newer", path, Ans) or "y"
		if ans == ans.upper():
			ans = Ans = ans.lower()
		if ans == "y":
			yield ("copy", "remote", path)
		elif ans == "r":
			yield ("copy", "local", path)
		elif ans == "d":
			yield ("delete", "local", path)
			yield ("delete", "remote", path)

	Ans = None
	for path in sorted(local_only):
		ans = ask("local only", path, Ans) or "y"
		if ans == ans.upper():
			ans = Ans = ans.lower()
		if ans == "y":
			yield ("copy", "remote", path)
		elif ans == "d":
			yield ("delete", "local", path)

	Ans = None
	for path in sorted(find_newer(remote, local)):
		ans = ask("ipod newer", path, Ans) or "y"
		if ans == ans.upper():
			ans = Ans = ans.lower()
		if ans == "y":
			yield ("copy", "local", path)
		elif ans == "r":
			yield ("copy", "remote", path)
		elif ans == "d":
			yield ("delete", "local", path)
			yield ("delete", "remote", path)

	Ans = None
	for path in sorted(remote_only):
		ans = ask("ipod only", path, Ans) or "y"
		if ans == ans.upper():
			ans = Ans = ans.lower()
		if ans == "y":
			yield ("copy", "local", path)
		elif ans == "d":
			yield ("delete", "remote", path)
	
	Ans = None
	for path in diffsize:
		local_size = local[path].st_size
		remote_size = remote[path].st_size

		msg = "%s larger [L %s, R %s]" % (
			"local" if local_size > remote_size else "remote",
			formatSize(local[path].st_size, 1),
			formatSize(remote[path].st_size, 1),
		)
		ans = ask(msg, path, Ans) or "n"
		if ans == ans.upper():
			ans = Ans = ans.lower()
		if ans == "l":
			yield ("copy", "remote", path)
		elif ans == "r":
			yield ("copy", "local", path)

# run queue

actions = list(sync())

if len(actions):
	run_queue(actions)
else:
	print "Nothing to do."
